Creating a Simple Java Program
-------------------------------
- It is possible to create multiple public class in one java file (single file program). But it must be executed by
java source_file.java command. This java file should contain first class defined have public static void main function.
And there is no requirement that this file should also have class defined by the name of java file.

- It also not a requirement for source.java need to have public class defined by source. But any first class defined in
a file should have psvm function if it were to be executed as single file program java source.java command.

- source.java file can have multiple classes defined which are not public and can be compiled by javac command. When complied
by javac command, it will create multiple .class files. Which can be executed by java xyz command, where xyz command line
option is xyz.class file generated by javac command

- final modifier can be used with this special main method.

- Use -d option with javac command. -d option is used to specify where to place generated class files. For java files relative path to
file can be given

- To run a java program with a particular version of java use command as follow
java --source 11 Test.java . Instructs the java command to process the Test.java file as Java 11 source code other options can be 11, 10, 9, 8

- Starting with JDK 11, it is possible to launch single-file source-code Programs. 

Working With Java Primitive Data Types and String APIs
------------------------------------------------------
- substring(int start, int to): start is inclusive, to in exclusive
- cannot use local variable without initializing it.
- toString method of StringBuilder class uses String constructor and does not use String literal. Hence when checked for
referential equality with literal it will always be false
- String.split(String pattern, int number). pattern is applied number - 1 times to string. e.g.
"BEVERAGE".split("E", 3). Pattern "E" is applied to BEVERAGE 3 - 1 = 2 times. Hence result of will be
array ["B", "V", "RAGE"]
- When using int variable to assign to short int variable has to be within short range and declared as final variable.
- When matching overloaded method with reference type method is always mapped to lowest class in hierarchy. If there are
two different non related classes then compiler will cause compilation error as compiler is not able to find method to
map a method.
- StringBuilder.append method is an overloaded method with form append(String) and append(StringBuffer). String and
StringBuffer is unrelated classes. So while passing null to append method, compiler has ambiguity in mapping right
method.
- String repeat(num) concatenate string num times.
- int var = (var = Test.var.length()); this type of statement is a valid statement.
- String and StringBuilder classes override toString() method, which prints the text stored in these classes.
- Compound declarations are allowed in Java for primitive type and reference type but not for var type.
Therefore following statement is a valid statement
int x = 7, y = 8; or float x = 7, y = 8;
and following statement is invalid statement
var x = 7, y = 8;

- Local variable Type inference was added in JDK 10 (var).
- casting wider primitive data type to narrower data type is possible in java as in C or other language. 
eg. byte b = (byte) 100000; would take eight bit value from 100000 and store in byte b.

- As String are immutable type. So if a String object is passed to a method with modifies that String object. Then the original String is not
modified but a new String object is created. So if that method does not returns this modified String object then original String object is not modified
and a newly created String object becomes eligible for garbage collection.

- You need to keep in mind an important point related to String Concatenation:
If only one operand expression is of type String, then string conversion is performed on the other operand to produce a string at run time.
If one of the operand is null, it is converted to the string "null".
If operand is not null, then the conversion is performed as if by an invocation of the toString method of the referenced object with no arguments; but if the result of invoking the toString method is null, then the string "null" is used instead.

- While concating an object with String, an objects toString() method is called.

- String class implements CharSequence. Hence reference variable of type CharSequence can point to String objects.


MAIN OBSERVATIONS
-----------------
- Under standing impact of usage of final keyword
- Mapping of overloaded methods as per passed parameter
- String and String Builder api documentation


Using Operators and Decision Constructs (12 questions) -- 67%
--------------------------------------------------------------
- We can cast an object in a chain to its parent, grand parent and further with following syntax
((GreatGrandParentClass)(GrandParentClass)(ParentClass)childObject).childMemberOrMethod

- . has a higher precedence than parenthesis so (ParentClass)childObject.stringVal will try to convert
stringVal member variable to ParentClass with is not possible as ParentClass in not related to String class.
Hence compilation error is generated.

- Array mismatch return first position where a miss match is found (0 based). So if position is 3, then mismatch
method will return 3 - 1 = 2. mismatch return -1 if no mismatch is found and null pointer position if either array is
null

- compare(x, y) return results as below
char: x - y
byte: x - y
short: x - y
int: -1 if x < y, 1 if x > y, 0 if x == y
double: -1 if x < y, 1 if x > y, 0 if x == y
boolean: 1 if x == true && y == false, -1 if x == false && y == true, 0 if x == y

- String can point to null and use + operator to concatenate more string null objects. But cannot call methods
on a null pointing string object.

- if (expression1 && expression2 && expression3) . if expression1 evaluates to false, then expression2 and expression3
are not evaluated.

- with newer version of java switch statement can take String arguments as well

- Local variable Type inference was added in JDK 10 (var variables). var in not a keyword, hence var can be used
as variable name, method name, package name or loop label. But it cannot be used as class or interface name.

- String.join api reference

- For decision construct like in if, we can use wrapper Boolean class also.

- if switch construct have default clause stated on top of other case clause and if no case statement is matched then default will be executed and fall
through all case statement if no break statement is encountered in the path.

- do while loop with continue statement.

- Following statement results in a compile-time error:
while (false) { x=3; }
because the statement x=3; is not reachable; but the superficially similar case:
if (false) { x=3; }
does not result in a compile-time error. An optimizing compiler may realize that the statement x=3; will never be executed and may choose to omit the code for that statement from the generated class file, but the statement x=3; is not regarded as "unreachable" in the technical sense specified here.

- statement -val returns negative value of val but does not modifies original value of val.

- //Postfix operator has higher precedence than other available operators 
e.g. -val-- would evaluate as -(val--) what this expression does it get the value of val, return its negated value and then decrement value of val by 1. So if val = 9, then above expression would return -9 and after evaluating this expression value of val is 8.
e.g. -(++val) what this expression does it get the value of val, increment it by one and return its negated value. 
So if val = 9, then above expression would return -10 and after evaluating this expression value of val is 10 


MAIN OBSERVATIONS
-----------------
- silly mistakes


Working with Java Arrays (6 questions) -- 50%
---------------------------------------------
- Array.mismatch(array1, array2) return zero based index of arrays where mismatch is found. mismatch function is
overloaded and it takes primitive data types only. boolean, char, byte, short, int, float, double.

- Elements of arrays are always initialized to their respective zeros for primitive types or null for reference types

- Array.compare(Array1, Array2), if any array (Array1, Array2) is a proper prefix of each other then function returns
Array1.length - Array2.length. If Array1 is not sub set of Array2, then each element of arrays are compared with rules
of compare method of their respective primitive types.

- Declaration of type var[] variable_name is not allowed.
- Declaration of type var variable_name = {1, 2, 3} also not allowed as Explicit target-type is needed for the
array initializer. E.g. var variable_name = new int[]{1, 2, 3}

- int [] arr1 = new int[8];` Creates one-dimensional array object to store 8 elements and arr1 refers to it. This statement compiles without any error.

- int [][] arr2 = new int[8][8];` Creates two-dimensional array object to store 8 * 8 = 64 elements. This statement also compiles fine.

- int [] arr3 [] = new int[8][];` Creates two-dimensional array object, whose 1st dimension is 8 but 2nd dimension is not yet defined. On the left side array symbols can be used before the reference variable or after the reference variable or can be mixed, hence int [][] arr3, int [] arr3 [] and int arr3[][] all are valid. This statement compiles successfully.

- int arr4[][] = new int[][8];: 1st array dimension must be specified at the time of declaration. new int[][8]; causes compilation error as 1st dimension is not specified.

- Legal ways to declare arrays
One dimensional array
int[] a, int a[]
two dimensional array
int[][] a, int[] a[], int a[][]

- Legal ways of using array initalizers
int[] ia = {1, 2, 3, 4, 5};
int[] ia = new int[]{ 1, 2, 3, 4, 5 };
int[] ia = new int[2]{ 1, 2 };//will not compile.

Object[] obj = {new Object(), new Object()};
Object[] obj = new Object[] {new Object(), new Object()};
Object[] obj = new Object[2] {new Object(), new Object()}; //will not compile

- Legal ways for using allocated and uninitalized array
int[] ia = new int[2];
Object[] obj = new Object[2];

- Legal ways for using multi-dimentional array initalizer
int[][] iaa = new int[2][3];
int[][] iaa = new int[3][];
int[][] iaa = new int[][]{ new int[]{ 1, 2 }, new int[]{ 3, 4 } }; is same as int[][] iaa = { { 1, 2 }, {3, 4 };
Object[] obj[] =  { {"string is also an object"}, {null } , { new Object() , new Integer(10)} }; 
 
- Be very observant about question asking you what options to choose so that program compiles only and not cause runtime exception. Or program that compiles
and executes successfully. These two question would have different answers. 


MAIN OBSERVATIONS
-----------------
- silly mistakes


Describing and Using Objects and Classes (1 question) -- 100%
-------------------------------------------------------------
- primitive type instance variables are initialized to their respective zeros and reference types to null
(char: \u0000, byte: 0, short: 0, int: 0, float: 0.0, double: 0.0, boolean: false)


Creating and Using Methods (5 questions) -- 80%
-----------------------------------------------
- non static member and methods cannot be accessed from static methods/static initializers

- Class name and method name can be same and that is why given method can be declared in any of the given classes: emp, Emp, employee, Employee, Student and _emp_. _emp_ is also a valid Java identifier. Hence class name can start with _ character.

- this(arguments); syntax is used to call one constructor from other constructor. 

- variable in methods cannot be declared private or protected.

- Method selection for overloaded message
1. The first rule is that having overloaded methods does not cause a compilation error by itself. In other words, as long as their method signatures are different, the compiler doesn't care whether they are too similar or not. Compilation error occurs only if the compiler is not able to successfully disambiguate a particular method call.

2. Exact match - If the compiler finds a method whose parameter list is an exact match to the argument list of the method call, then it selects that method. For example, consider the following two methods: 
void processData(Object obj){ }
void processData(String str){ } 
and the method call processData("hello");. Since String is an Object, the String argument matches the parameter list of both the methods and so both the methods are capable of accepting the method call. However, String is an exact match to the argument and so the compiler will select the second method. 
This rule applies to primitives as well. Thus, out of the following two methods, the first method is selected when you call processData(10); because 10 is an int, which matches exactly to the parameter type of the first method even though the long version of the method is also perfectly capable of accepting the value. 
void processData(int value){ }
void processData(long value){ } 

3. Most specific method - If more than one method is capable of accepting a method call and none of them is an exact match, the one that is "most specific" is chosen by the compiler. For example, consider the following two methods: 
void processData(Object obj){ }
void processData(CharSequence str){ } 
and the method call processData("hello");. Remember that String extends CharSequence and CharSequence extends Object. Thus, a String is a CharSequence and a String is also an Object. So here, neither of the methods has a parameter list that is an exact match to the type of the argument but both the methods are capable of accepting a String. However, between Object and ChareSequence, CharSequence is more specific and so the compiler will select the second method.

Since primitives are not classes, there is no subclass/superclass kind of relation between them as such but Java does define the subtype relation for them explicitly, which is as follows: 
double > float > long > int > char 
and 
int > short > byte 
What it means is, float is a subtype of double, long is a subtype of float, int is a subtype of long, and char is subtype of int. And also, short is a subtype of int and byte is a subtype of short. Based on the above, you can easily determine which of the following two methods will be picked if you call processData((byte) 10);
void processData(int value){ }
void processData(short value){ } 
The short version will be picked because short is a subtype of int and is therefore, more specific than an int.

4. Consider widening before autoboxing - Since autoboxing only came into existence when Java 5 was released, it is necessary to give higher priority to the primitive versions if the argument can be widened to the method parameter type so that existing code will keep working as before. Therefore, out of the following two methods, the short version will be picked instead of the Byte version if you call processData( (byte) b); even though the Byte version is an exact match with byte after autoboxing.
void processData(short value){ }
void processData(Byte value){ } 

5. Consider autoboxing before varargs - This rule mandates that if an argument can be autoboxed into a method parameter type then that method be considered even if a method with varargs of the same type is available. This explains why if you call processData(10); then the Integer version (and not the int... version) is picked out of the following two. 
void processData(int... values){ }
void processData(Integer value){ }  






Applying Encapsulation (2 questions) -- 100%
--------------------------------------------
- access modifier in order from most to least restrictive private,
default (no access modifier specified with is package-private), protected, public

- if java file contains non public class and public class it will compile successfully. But non public class will
only be visible in its package only while public class is access anywhere (verify it).


Reusing Implementations Through Inheritance (6 questions) -- 67%
----------------------------------------------------------------
- Instance variable are hidden and not overridden by sub classes

- Dot operator has higher precedence than parentheses. e.g. (Parent)gc.quote will evaluate gc.quote first which is of
type String. Then (Parent) cast is evaluated, but quote (String) is not of type Parent hence it will lead to compilation
error.

- Chain of casting is also possible for subclass to super class. e.g ((Parent)(Child)gc).quote this expression will first
cast gc object to first Child and then to Parent object. Then Parent class quote member variable is referenced.

- Access modifier of overriding method should either be same as the access modifier of overridden method or it should
be less restrictive than the access modifier of overridden method.

- An overriding method cannot put a wider exception (i.e. a superclass exception) in its throws clause than the ones present in the throws clause of the overridden method. For example, if the overridden method throws IOException, the overriding method cannot throw Exception because Exception is a superclass of IOException. 

- In a sub class you cannot override a static method as instance method or instance method as static method.

- protected member variables can only be accessed in subclass using using inheritance but not using object reference
variable if a sub class is defined in different package. If sub class is defined in same package then protected, default
access modifier variable can be access via inheritance as well as through object reference.

- member variable inherited from super class can be access with this or super keyword.

- Constructors cannot use final, abstract or static modifiers

- abstract methods cannot be private, final and static

- Using static and final in methods are redundant. When a static method is overridden in a subclass it can still be accessed via the super class, making a final declaration not very necessary. Declaring a static method final does prevent subclasses from defining a static method with the same signature.

- sub class object is an instance of super class. Hence childClassObject instanceof Superclass returns true. But other
way round super class in not an instance of child class.

- If Super class reference variable points to sub class object. Then this variable will point to super class member
variable and sub class member methods.

- rules related to return types of overriding methods
A. If return type of overridden method is of primitive type, then overriding method should use same primitive type.
B. If return type of overridden method is of reference type, then overriding method can use same reference type or
its sub-type (also known as covariant return type).

- In case of overriding, if overridden method declares to throw any RuntimeException or Error, overriding method
may or may not throw any RuntimeException but overriding method must not throw any checked exceptions.

- In generics syntax, Parameterized types are not polymorphic, this means even if B is subtype of A,
List<B> is not subtype of List<A>. Remember this point. So below syntax are NOT allowed:

  List<A> list = new ArrayList<B>(); OR ArrayList<A> list = new ArrayList<B>();

- Another way/syntax to extend a class can be
ParentClass parentClass = new ParentClass() {
    // child class code
    };

- Static methods in Java are inherited, but can not be overridden. If you declare the same method in a subclass,
you hide the superclass method instead of overriding it. Static methods are not polymorphic. At the compile time,
the static method will be statically linked.

- If a super class variable points to subclass variable then it is legal to cast super class variable to sub class variable, although it is redundant.
eg. X --> Y --> Z
X x = new Z();
(Y)x; // legal and will compile even though its redundant
(Z)x; // legal and will compile even though its redundant

- ClassCastException is thrown if two super class variable point to sibling child classes if one sibling object is converted to other sibling object using a
super class variable then ClassCastException is thrown.
eg. A-->B, A-->C
A a1 = new B();
A a2 = new C();
C c1 = (A)a1; // will compile fine but will throw ClassCastException.

- private or protected modifier cannot be used at class level

- Even though class is declared public but if its constructor is declared with default modifier (package private) we will not be able to inherit from that
class in other package or even instantiate that class.

- Order of initalizers summarized
A --> B (B is sub class of A)
1. static initializers of A and B are invoked before B's main() is executed because the JVM needs to load the class before it can invoke a method on it.
2. Static initializers of A and B are invoked only once even though two objects of B are created.
3. Instance initializer of A is executed before A's constructor even though the instance initializer appears after the constructor in A's code.
4. While creating an object of B, A's instance initializer and constructor are invoked before B's instance initializer and constructor.
5. Instance initializer and constructor of A are invoked each time an object of B is created.

- Summary of the application of access modifiers, final, abstract, and static keywords
1. An abstract class doesn't necessarily have to have an abstract method but if a class has an abstract method, it must be declared abstract. In other words, a concrete class cannot have an abstract method.
2. An abstract class cannot be instantiated irrespective of whether it has an abstract method or not.
3. A final class or a final method cannot be abstract.
4. A final class cannot contain an abstract method but an abstract class may contain a final method.
5. A private method is always final. 
6. A private method can never be abstract.
7. A static method can be final but can never be abstract.

- you can cast any type of reference to any interface. That's true except in one case. If the declared class of the variable is final and if that class does not implement the interface given in the cast, the compiler knows that this class can never have any subclass and therefore, it knows that there is no way the reference can point to an object of a class that extends this class and also implements the given interface. For example, String is a final class and the following code will not compile for the same reason: 
String s = new String();
Poisonous p = (Poisonous) s; //will not compile
But you cannot cast unrelated class objects to each other.
StringBuilder sb = (StringBuilder) new String("Hello World!); // will not compile

- You need casting when you want to use the features (i.e. instance variables and methods) defined in a subclass using a reference whose declared type is of a superclass.

-  static methods, static variables, and instance variables are accessed as per the declared type of the variable through which they are accessed and not according to the actual type of the object to which the variable refers. 

- There are different ways in which static method of an abstract class can be accessed:
(Abstract class) A --> MyClass
1. By using the name of the abstract class: A.log(); //Preferred way
2. By using the reference variable of abstract class: A o1 = null; o1.log();
3. By using the name of the subclass: MyClass.log();
4. By using the reference variable of the subclass: MyClass o2 = null; o2.log();

- when instanceof is used on unrelated classes its causes compilation error. The compiler will let you use instanceof operator only if it is possible for the variable to refer to an object of the type given on the right-hand side. For example, f instanceof Mango is valid because the compiler knows that the declared type of f is Fruit and since Mango is a Fruit, it is possible for f to point to a Mango. But f instanceof String will not compile because the compiler knows that there is no way f can ever point to a String.

- An abstract child sub class can declare overriding method of super class as abstract.

- Child class can extend a concrete class and still be declared abstract.  


Programming Abstractly Through Interfaces (18 questions) -- 56%
---------------------------------------------------------------
- Interface abstract methods are always public and implicitly method. You don't have to specify abstract keyword.

- Interface fields cannot be protected or private. All variables defined in an interface are implicitly public, static, and final. 

- default methods are just the opposite of abstract methods. They are defined using the keyword default. Default methods are always public even if you do not declare them as such explicitly. You cannot mark them private or protected. default methods are part of object (Class instance)

- static methods - As the name implies, static methods belong to the interface itself and not to the object implementing that interface. They are defined using the keyword static. Static methods can be marked public or private but not protected. If no access modifier is specified, they are implicitly public. Static methods cannot be marked default either. static methods are not inherited but always remain part of interface only.

- Static methods of interface can only be invoked only as InterfaceName.nameOfStaticMethod(); and not by instance of class implementing the interface.

- Private methods (static as well as no-static) have been allowed since Java 9 and, as explained above, they are helpful when a default and static methods gets too big and needs to be refactored into smaller internal methods without exposing the internal methods to the outside world.

- Since methods of an interface are meant to be implemented by the classes that implement the interface, methods of an interface cannot be declared final.

- methods in interface are by default abstract and abstract method cannot have a body. If we need to provide a
method with implementation, we need to declare that method with default or private keyword and
provide an implementation.

- Syntax of class implementing multiple interfaces as class MyClass implements Interface1, Interface2 {}

- it is possible for a class to inherit multiple implementations of a default method from more than one interface.  JVM will have ambiguity which method to invoke on than object. So Java resolves this problem by forcing the class to provide an implementation of the method of its own to remove the ambiguity in invocation.  

- above rule also valid if one interface have default method and other has abstract method with same signature.

- In Interfaces Java allows a class to inherit multiple fields with the same name as long as you don't try to use those fields ambiguously. To remove ambiguity use fields with their Interface name. e.g. Interface1.myVar and Interface2.myVar

- Syntax for interface to extend interface
single interface: Interface Interface2 extends Interface1 {}
multiple interface: Interface Interface3 extends Interface1, Interface2, OtherInterface {}

- Remember that a class cannot extend an interface, it can only implement an interface. Whereas, an interface cannot implement any interface it can only extend an interface. 

- If an interface inherit two default methods or one abstract and other default method with same signature, then the inheriting interface should provide its own implementation of default method (like than in class) else it will be a compile error.

- If two or more super interfaces have abstract method with same name, so inheriting interface will get only one copy of abstract method and hence class implementing that interface will have to provide only one implementation of that abstract method. 

- Static fields of an interface are inherited by a sub interface and therefore ReadWritable does get two versions of SIZE variable. Java allows an interface to inherit multiple fields with the same name as long as you don't try to use those fields ambiguously. 
  
- Inheriting interface can provide implementation of abstract methods inherited from its super interface.

- Since, due to type erasure, generic information is removed at run time, it follows that generic information cannot be a part of the signature. Thus, two methods that differ only in their type parameters are not valid overloads.

- Read about writing generic class

- Read about writing generic methods	

- Generics were added quite late to Java (only in 1.5) and so backward compatibility was an important concern. Furthermore, since it was a fairly complicated feature, it was expected that their wide spread usage will take some time. Thus, it was deemed necessary that code that uses Generics must work with code that doesn't use Generics. To achieve this design goal, the mechanism of type erasure was used, where all the generic information is stripped from a class at run time. Thus, even if you write ArrayList<String> al = new ArrayList<>(); in your code, the JVM will only see ArrayList al = new ArrayList();. The type information is effectively "erased" from a class for the JVM.

- Since, due to type erasure, generic information is removed at run time, it follows that generic information cannot be a part of the signature. Thus, two methods that differ only in their type parameters are not valid overloads.

- Even though due to erasure, generic information is removed at run, this would result of valid override even if types are different. But java will not allow a code to compile if type information are different in overriding methods. In other word for a valid overriding methods should have same type for generic parameters.
eg.
class A { void processData(List<String> data){}}
class B extends A { void processData(List<Integer> data){}} is an invalid override
but
class A { void processData(List<String> data){}}
class B extends A { void processData(List<String> data){}} is an valid override

- hierarchy of Collections interfaces and classes that you will see on the exam.
> Collection
> List
> ArrayList

- It declares only the methods that are applicable to all sorts of collections and leaves the methods that deal with specialized features such as ordering or uniqueness of elements to sub-interfaces such as List and Set. For example, Collection declares add(Object e) and remove(Object e) methods but does not declare add(int index, Object e) and remove(int index) because the concept of ordering is not applicable to all collections. We use the Collection interface when we don't want to make any assumption about the characteristics of the group of objects. In other words, if we get a Collection object, all we know is that it contains a bunch of elements.

- Advantages of ArrayList ☝
1. Dynamic sizing - An ArrayList can grow in size as required. The programmer doesn't have to worry about the length of the ArrayList while adding elements to it.
2. Type safety - An ArrayList can be made type safe using generics.
3. Readymade features - ArrayList provides methods for searching and for inserting elements anywhere in the list.

- Disadvantages of ArrayList ☝
1. Higher memory usage - An ArrayList generally requires more space than is necessary to hold the same number of elements in an array.
2. No type safety - Without generics, an ArrayList is not type safe at all.
3. No support for primitive values - ArrayLists cannot store primitive values while arrays can. This disadvantage has been mitigated somewhat with the introduction of autoboxing in Java 5, which makes it is possible to pass primitive values to various methods of an ArrayList. However, autoboxing does impact performance.

Similarities between ArrayLists and arrays ☝
1. Ordering - Both maintain the order of their elements.
2. Duplicates - Both allow duplicate elements to be stored.
3. nulls - Both allows nulls to be stored.
4. Performance - Since an ArrayList is backed by an array internally, there is no difference in performance of various operations such as searching on an ArrayList and on an array.
5. Thread safety - Neither of them are thread safe. Don't worry, thread safety is not on the exam, but you should be aware of the fact that accessing either of them from multiple threads, may produce incorrect results in certain situations.
 
- Arrays.asList method returns a fixed-size list backed by the specified array and as list is backed by the specified
array therefore, you cannot add or remove elements from this list. Using add/remove methods cause an
exception at runtime. But you can invoke the set(int index, E element) method on the returned list.

- List.of method, which returns unmodifiable list, hence calling add/remove/set methods on the unmodifiable list throws
an exception at runtime

- Iterable<T> interface has forEach(Consumer) method.  List<E> extends Collection<E> &
Collection<E> extends Iterable<E>, therefore forEach(Consumer) can easily be invoked on reference variable of
List<E> type.

- forEach(Consumer) method performs the given action for each element of the Iterable until all elements have been
processed or the action throws an exception. Consumer is a functional interface, hence a lambda expression can be
passed.

- abstract class in java can have 0 or more abstract methods



-clone method of list interface create a shallow copy of list object. Means if an original list contains reference
variables then after clone method a new list object is created which contains same reference objects as original
object.

- All wrapper classes Integer, Float, Double, Character, Byte, Short, Boolean are immutable classes like a String class.

- If lambda expression is in {}, then it should have complete expression including semicolons and return statement if
required.

- While implementing an interface method, this method should not have weaker access modifier than declared in interface.
Interface methods are public implicitly, so class which implements interface should also declare methods as public.

- Study ques40 for a very peculiar example of sub class implementing interface and extending base class which does not
implements any interface but has a same method implemented as its member method (Test 2).

- Functional Interface can have only one non-overriding abstract method. Apart from it a functional interface can have
constant variables, default methods, private methods, overriding abstract methods like public String toString(), public boolean equals(Object)
and public int hashCode().

- While traversing a list using an iterator, if it is required to remove item from list use Iterator.remove or
ListIterator.remove method, rather than List.remove method. As later method will throw
java.util.ConcurrentModificationException.

- Variables defined in interface are implicitly public final static. Correct way of access interface variable is with
syntax InterfaceName.variableName. But reference type can also point to interface variables.

- remove(Object o) method of list return true if object was removed successfully or false otherwise.

- remove(int index) remove the element of list at index and returns that element.

- add(E e) method of list return true if object was added successfully or false otherwise.
- add(int index, E element) inserts element at index. It returns void. if index is < 0 or > list length, then
IndexOutOfBound exception is thrown.




MAIN OBSERVATIONS
-----------------
- under stand list api functions


Handling Exceptions (8 questions) -- 63%
----------------------------------------

- A function can declare to throw any exception(s) with throws clause. e.g public void copyFile(String inputPath, String outputPath) throws IOException{}

- A method can throw multiple type of exception with following syntax void method() throws IOException, SQLException, FileNotFoundException{}

- Calling method can deal with called method throwing exception in two ways.
1. By handling exception in try/catch block
2. By declaring throws clause in method declaration. 

- Method can use throw keyword to throw any exception from method body.

- Note that curly braces for the try, catch, and finally blocks are required even if there is a single statement in these blocks  (compare that to if, while, do/while and for blocks where curly braces are not required if there is only one statement in the block).  Furthermore, a try block must follow with at least one catch block or the finally block. A try block that follows with neither a catch block nor a finally block will not compile. 
 

- In exception handling order in which catch block is specified matter. if subclass exception is specified after super
class exception, then it will be a compile error, compiler will state is as unreachable code.

- RuntimeException can be thrown without any need to be declared in throws clause of surrounding method.
throw (RuntimeException)e;` doesn't cause any compilation error. Even though variable 'e' is type casted to
RuntimeException but exception object is still of ArithmeticException, which is caught in main method and
'AE' is printed to the console. (Ques 6)

- Java doesn't allow to catch specific checked exceptions if these are not thrown by the statements inside try block.<--- Verify this

- If an instance of Exception is thrown by the catch-block but another catch-block at the same level are not executed.
Explaining this point further, in a try catch block with multiple catch blocks only one of the catch block is executed
even though an executed catch block throws new other type of exception. And as usual finally block is always executed.

- If a method has a throws clause and it throws unchecked exception then calling method don't need to handle that
exception. But if method throws checked exception then calling method needs to handle that exception by either
try/catch block or add throws clause to method signature.

- Casting Super class Exceptions like RuntimeException to sub class exception like ArithmeticException will cause ClassCastException to be thrown.

- Hierarchy of Exception framework
java.lang.Throwable (Root of all exception classes, is covered under checked exception)

- An overriding method can only throw Checked exception and its sub type if and only if super class overridden method declared it throws checked exception.

- For instance if super class method throws IOException, so its legal for sub class to override a method with FileNotFoundException. But if super class overridden method is called in sub class overriding method, using super keyword then it will cause a compilation error as super class method throws a wider exception (IOException) and sub class throws only narrower exception (FileNotFoundException), which is illegal in java. Same rationale can be used in try catch block also, if try block throws wider exception and catch block only have narrower exception, it will be a compilation error. 

- An overriding method can throw unchecked exception even if its super class method does not throws any exception.

- Overriding method can choose not to throw any checked exception or throw any unchecked exception even if its super class overridden method throws checked exception. The other way rule applies to sub class overriding method.

- multi catch syntax: catch (Exception1 | Exception2 ex) {}. But Exception1 and Exception2 must be unrelated exception i.e. they should not have any is-a relationship.

- According to overriding rules, if super class / interface method declares to throw a checked exception, then overriding method of sub class / implementer class has following options:
1. May not declare to throw any checked exception.
2. May declare to throw the same checked exception thrown by super class / interface method.
3. May declare to throw the sub class of the exception thrown by super class / interface method.
4. Cannot declare to throw the super class of the exception thrown by super class / interface method.
5. Cannot declare to throw unrelated checked exception.
6. May declare to throw any RuntimeException or Error.

- Java follows a convention in naming exception classes. This convention is sometimes helpful in determining the kind of exception you are dealing with. The name of any class that extends Error ends with Error and the name of any class than extends Exception ends with Exception. For example, OutOfMemoryError and StackOverflowError are Errors while IOException, SecurityException, IndexOutOfBoundsException are Exceptions. However, there is no way to distinguish between unchecked exceptions that extend RuntimeException and checked exceptions just by looking at their names. It is therefore, important to memorize the names of a few important runtime exception classes, namely - NullPointerException, ArrayIndexOutOfBoundsException, ArithmeticException, ClassCastException, and SecurityException.

Checked Exceptions
------------------
java.lang.Exceptions (Extends java.lang.Throwable)
some subclasses
> java.io.IOException
> java.sql.SQLException

Unchecked Exceptions
--------------------
java.lang.Error (Extends java.lang.Throwable)
some subclasses
> java.lang.AssertionError
> OutOfMemoryError
> java.lang.StackOverflowError

java.lang.RuntimeException
some subclasses
> java.lang.NullPointerException
> java.lang.ArrayIndexOutOfBoundsException
> java.lang.ArithmeticException
> java.lang.ClassCastException


- Common Exceptions that are usually thrown by the JVM
1. ArithmeticException extends RuntimeException. The JVM throws this exception when you try to divide a number by zero.
2. ClassCastException extends RuntimeException. The JVM throws this exception when you try to cast a reference variable to a type that fails the IS-A test.
3. IndexOutOfBoundsException extends RuntimeException. This exception is a common superclass of exceptions that are thrown where an invalid index is used to access a value that supports indexed access. For example, the JVM throws its subclass ArrayIndexOutOfBoundsException when you attempt to access an array with an invalid index value such as a negative value or a value that is greater than the length (minus one, of course) of the array. Methods of String class throw another of its subclass StringIndexOutOfBoundsException when you try to access a character at an invalid index.
4. NullPointerException extends RuntimeException 
The JVM throws this exception when you attempt to call a method or access a field using a reference variable that is pointing to null. 


- Common Errors usually thrown by the JVM
1. ExceptionInInitializerError extends Error. The JVM throws this Error when any exception is thrown while initializing a static variable or a static block. 
2. OutOfMemoryError extends Error. The JVM throws this Error when it runs out of memory. This usually happens when a programs creates too many objects. 
3. StackOverflowError extends Error. The JVM throws this Error when the thread executing the method runs out of stack space.

- Exceptions thrown by Application Programmer
1. IllegalArgumentException extends RuntimeException. This exception is thrown when a method receives an argument that the programmer has determined is not legal. 
2. NoClassDefFoundError extends Error.Although it is an Error but it is not thrown by the JVM. It is thrown by a class loader (which is just another class in Java standard library) when it is not able to find the definition of a class that it is trying to load. Beginners get this error often while trying to run their program. For example, if your class has a package statement but you have not put the class file in its proper directory structure, the system class loader will not be able to find that class when you try to run it and will throw this error.
3. NumberFormatException extends IllegalArgumentException. This exception is thrown when a method that converts a String to a number receives a String that it cannot convert. 
4. SecurityException extends RuntimeException. This exception is thrown if the Security Manager refuses to permit the requested operation due to restrictions placed by the JVM. For example, when a Java program runs in a sandbox (such as an applet) and tries to use prohibited APIs such as File I/O, the security manager throws this exception. Since this exception is explicitly thrown using the new keyword by a security manager class, it can be considered to be thrown by the application programmer. 

- If there is a possibility of a checked exception getting thrown out of a method, then that exception or its superclass exception must be declared in the throws clause of the method. 
Some of valid method declaration for methods throwing exception
1. void foo(int x) throws Exception{
    if(x == 2) throw new Exception(); //throws Exception only if x==2
    else return;
}

2. void foo() { //no throws clause necessary
    if(someCondition) throw new RuntimeException();
    else throw new Error();
}

3. void foo() throws Exception{
    if(someCondition) throw new java.io.IOException(); //throwing a sub-exception
    else return;
}

4. void foo() throws java.io.IOException{ //will not compile
    if(someCondition) throw new Exception(); //throwing a super-exception
    else return;
} 

5. void foo() throws java.io.IOException, java.sql.SQLException //can throw a common superclass exception as well.
{  
    if(someCondition) throw new java.io.IOException();
    else throw new java.sql.SQLException();
}

6. void foo() throws Exception, java.io.IOException{//specifying IOException is redundant because IOExcception is a subclass of Exception
    if(someCondition) throw new java.io.IOException();
    else throw new java.sql.SQLException();
}

7. void foo() throws Exception{ //declaring Exception in the throws clause even though it is not thrown by the method body
   System.out.println("hello");
}

8. void foo1() {
    try{
       if(someCondition) throw new Exception(); //will be caught by the catch block
       else return;
    }catch(Exception e){
       
    }
}

9. void foo2() throws Exception{
    try{
       if(someCondition) throw new Exception(); 
       else return;
    }finally {
       System.out.println("in finally"); //will be executed but the exception is not caught here
    }
}

10. void foo() throws Throwable{
    if(true) throw new Exception();
    else return;
}

- Therefore, if a static initializer ends up throwing an exception, there is no way for the application to handle that exception and to recover from it. For this reason, a static initializer is not allowed to throw any checked exception. If the compiler sees a possibility of a checked exception getting thrown out of a static initializer, it will generate an error.

- However, an instance initializer has the same problem as a static initializer - there is no way to specify a throws clause for an instance initializer. Recall that an instance initializer is executed no matter which constructor of the class is invoked. In that sense, an instance initializer is kind of a part of each constructor of the class. Therefore, an exception thrown from an instance initializer can be thought of as an exception thrown by every constructor of the class. Thus, if we declare an exception thrown from an instance initializer in the throws clause of each constructor of the class, we should be good.
e.g TestClass() throws Exception{}

- Just like a method, a constructor is allowed to throw any exception as long as it declares that exception in its throws clause. However, there is one important difference between a method and a constructor. Recall that the first line of every constructor is always a call to a constructor of its super class or to another constructor of the same class. Thus, if a constructor decides to throw an exception, it has an impact on the subclass because that exception will be propagated to the subclass constructor as well. Therefore, if a subclass constructor invokes a superclass constructor that throws an exception, that subclass constructor must also declare that exception in its throws clause. try/catch block usually doesn't work in constructor, again because first line has to be a call to constructor of its super class or to another constructor of the same class.

- It is ok to use a catch block with a broader exception class to catch a narrower exception.

- The reverse, i.e., using a catch block with a narrower exception to catch a broader exception is not acceptable.

- If a method doesn't want to catch the exception then it must declare that exception (or its superclass) in its throws clause. This is no different from the rule that you have seen before while creating a method that throws an exception. 

- Unreachable catch blocks. What if you move the catch(IOException ioe) block before the catch(FileNotFoundException fnfe) block? Well, the code will fail to compile. The catch(IOException ioe) clause will always satisfy a FileNotFoundException and so the control will never get to enter catch(FileNotFoundException fnfe) block.

- But remember that a catch block associated with a nested try statement is cannot catch an exception thrown by the outer try block. 

- It is possible to rethrow the same exception (or throw a new one) from the catch block. You may want to do this if you want to do something upon receiving an exception before letting it propagate up the call chain. Of course, if it is a checked exception you would have to declare it in the throws clause of the method. The same effect can be achieved with a finally block. 

- Since there is no catch block to catch the Exception thrown by method from catch/finally block, the exception will automatically be thrown out of the method to the caller of method, but only after the code in the finally block is executed.

- If you throw an exception from the finally block, then the exception thrown from the try block or the catch block is ignored, and the exception thrown from the finally block is what gets thrown out of the method. 

- Even though the catch block throws Exception, the JVM doesn't throw it to the caller of bar. It waits until the finally block finishes execution. However, the finally block throws a new IOException. So the JVM ignores the Exception that it was about to throw to the caller and throws the IOException instead. As far as the compiler is concerned, it realizes that bar can only throw an IOException and not Exception to the caller and therefore, it is ok with listing just IOException in bar's throws clause.


MAIN OBSERVATIONS
-----------------
- under stand exception framework hierarchy

Understanding Modules (8 questions) --50%
------------------------------------------
- command to compile modules
javac -d <output_directory> -p <module_path> --module-source-path <root_source_directory> -m <modules_to_compile>
 -p option can also be provided as --module-path
 -m option can also be provided as --module
-d <output_directory>: directory where compiled module will be placed
-p <module_path>: list of path separated by ; on windows and : on linux/mac which contains various modules which may be
required during the compilation of <module_to_compile>
--module-source-path <root_source_directory>: root source directory where all modules are kept
-m <module_to_compile>: name of module directory to compile. Multiple modules are separated by commas
NOTE: -p option is not required if a module to compile does not require any external module to refer during compilation
Type of module that can be referred by -p option: singlemodules, exploded modules, modular jar

- command to create jar files
jar -c -e <main_class_name> -f <jar_file_name> -C <change_to_dir_to_include_files>
explanation of command line arguments
-c or --create: Create the archive
-f or --file=FILE: The archive file name
-e or --main-class=CLASSNAME
-C DIR: change to specified directory and include the following

- command to execute modules
java -p <module_path> -m <module>[/<mainclass>] [args...]
 -p option can also be provided as --module-path
 -m option can also be provided as --module
module_path(s) are separated by ; on windows and : on linux/mac
if each different module paths contain same module in them then first module path containing the requested module
is executed and other module paths are ignored. (see question 12). -m option should be the last option as it could
contain command line options.

- exploded module is module with its own directory structure and class file. In exploded module main class is
not optional.

- to create a jar file. First compile module from source file to class files as exploded module. From this exploded module create jar file as described above (jar command).

- some of valid module directives
 exports
 requires
 requires transitive
a module cannot export standard module of java platform e.g. java.se

- requires or requires transitive directive should have module name and not package name in their declaration. 

- requires transitive: Implied readability is to specify a transitive dependency on another module such that other
modules reading your module also read that dependency.
For example, if module C has `requires B;` (C reads B) and module B has `requires A;` (B reads A),
then C doesn't read A.

To have the transitive readability, 'requires transitive' directive is used. If module C has `requires B;`
(C reads B) and module B has `requires transitive A;` (B reads A [transitive dependency]), then C will also read A.

- export module to specific modules
exports <package_name> to <comma_separated_list_of_modules>;
if to <comma_separated_list_of_modules> is missing then package is exports to all modules
Also note that having multiple exports directive for same package is note allowed,
below code causes compilation error:

exports com.udayankhattry.books to bookhouse;
exports com.udayankhattry.books to onlinestore;
but instead it should be
exports com.udayankhattry.books to bookhouse, onlinestore;

- A module is a set of packages and all the classes should be part of some package (not the default package).
unnamed package is not allowed in named modules (see question 35)

- In module-info.java name of module should be same as its root directory

- Java Platform Module System was introduced in Java 9 as project jigsaw

- If a module have two packages e.g
dev.dmohindru.example;
dev.dmohindru.example.test;

and moduel-info.java has following code
module fullyQualifiedModuleName {
exports dev.dmohindru.example;
}
so this module declaration will export only dev.dmohindru.example package and not its sub package dev.dmohindru.example.test

- By default, all the Java modules are dependent on java.base module. There is no need to have 'requires' directive in the module descriptor file (module-info.java) for java.base module.

- To get a list of all the system modules, use below command:
java --list-modules

- And to check details of specific module (e.g. java.base), use below command:
java --describe-module java.base










Current read
------------
Understanding Modules - Ques 54
