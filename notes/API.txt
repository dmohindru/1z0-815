String
-------
- String constructors
1. String() - The no-args constructor creates an empty String.
2. String(String str), String(StringBuilder sb) - Create a new String by copying the sequence of characters currently contained in the passed String or StringBuilder objects.
3. String(byte[] bytes) - Creates a new String by decoding the specified array of bytes using the platform's default charset.
4. String(char[] value)- Creates a new String so that it represents the sequence of characters currently contained in the character array argument.

- public String[] split​(String regex, int limit) 
It returns the String[] after splitting this string around matches of the given regex.
The limit parameter controls the number of times the pattern is applied and therefore affects the length of the resulting array. 
If the limit is positive then the pattern will be applied at most (limit - 1) times
If the limit is zero or less than zero then the pattern will be applied as many times as possible.
Or in other words this split will return String array of max length limit if limit > 0.

- public String[] split​(String regex) {...}: It returns the String[] after splitting this string around matches of the given regular expression.
This method works as if by invoking the two-argument split method with the given expression and a limit argument of zero. Trailing empty strings are therefore not included in the resulting array. 
"BAZAAR".split("A"); returns ["B","Z","","R"] as this statement is equivalent to "BAZAAR".split("A", 0);.
":".split(":"); returns blank array as this statement is equivalent to ":".split(":", 0);.

- int indexOf(String str) method of String class returns the index within this string of the first occurrence of the specified substring or -1 if not found. e.g. "Java".indexOf("a") returns 1.

- int indexOf(int ch)- Returns the index within this string of the first occurrence of the specified character.  Returns -1 if the character is not found.

- char charAt​(int index) method of String class returns the char value at the specified index. e.g. "Java".charAt(2) returns 'v'. If index is >= length of String then StringIndexOutOfBoundException is thrown.

- isEmpty() method of String class returns true if and only if length() is 0.

- isBlank() method of String class (available since Java 11) returns true if the string is empty or contains only white space codepoints, otherwise false.


- String concat(String str) - Concatenates the specified string to the end of this string.
Example - System.out.println("1234".concat("abcd")); //prints 1234abcd

- int length() - Returns the length of this string.

- String substring(int beginIndex, int endIndex) - Returns a new string that is a substring of this string. beginIndex (inclusive), endIndex(exclusive). If endIndex is > length of String then StringIndexOutOfBoundException is thrown.

- String substring(int beginIndex) - This method works just like the other substring method except that it returns all the characters from beginIndex (i.e. including the character at the beginindex) to the end of the string (including the last character). If endBegin is > length of String then StringIndexOutOfBoundException is thrown.

- String toLowerCase()/toUpperCase() - Converts all of the characters in this String to lower/upper case. 
Example - System.out.println("ab".toUpperCase()); //prints AB

- String replace(char oldChar, char newChar) - Returns a new string resulting from replacing all occurrences of oldChar in this string with newChar.
Example: System.out.println("ababa".replace('a', 'c')); //prints cbcbc

- String strip(), stripLeading(), stripTrailing(), trim() - Returns a copy of the string, with leading and/or trailing white space omitted.
Example:
System.out.println(" 123 ".strip()); //prints "123" (without the quotes)
System.out.println(" 123 ".stripLeading()); //prints "123 " (without the quotes)
System.out.println(" 123 ".stripTrailing()); //prints " 123" (without the quotes)
System.out.println(" 123 ".trim()); //prints "123" (without the quotes)

- One interesting thing about the String manipulation methods detailed above is that they return the same string if there is no change in the string as a result of the operation.

- boolean startsWith(String prefix): Returns true if this string starts with the specified prefix.

- boolean endsWith(String suffix): Returns true if this string ends with the specified suffix.

- boolean contains(CharSequence s): Returns true if and only if this string contains the specified sequence of char values.

- boolean equals(Object anObject): Returns true if the contents of this string and the passed string are exactly same. Observe that the type of the parameter is Object. That's because this method is actually defined in the Object class and the String class overrides this method. So, you can pass any object to this method, but if that object is not a string, it will return false.

- boolean equalsIgnoreCase(String anotherString): Compares this String to another String, ignoring case considerations.

- String.valueOf( ... ) is invoked to generate a string representation of the argument that is passed. For example, String.valueOf(123) returns the String "123"

- public String repeat​(int count) Returns a string whose value is the concatenation of this string repeated count times. If this string is empty or count is zero then the empty string is returned. Throws IllegalArgumentException - if the count is negative.

- public static String join(CharSequence delimiter, CharSequence... elements) {...}: It returns a new String composed of copies of the CharSequence elements joined together with a copy of the specified delimiter.
For example,
String.join(".", "A", "B", "C"); returns "A.B.C"
String.join("+", new String[]{"1", "2", "3"}); returns "1+2+3"
String.join("-", "HELLO"); returns "HELLO"

If delimiter is null or elements refer to null, then NullPointerException is thrown. e.g.,
String.join(null, "A", "B"); throws NullPointerException
String [] arr = null; String.join("-", arr); throws NullPointerException

But if single element is null, then "null" is considered. e.g.,
String str = null; String.join("-", str); returns "null"
String.join("::", new String[] {"James", null, "Gosling"}); returns "James::null::Gosling"

- public static String join​(CharSequence delimiter, Iterable<? extends CharSequence> elements) {...}: It returns a new String composed of copies of the CharSequence elements joined together with a copy of the specified delimiter.

For example,

String.join(".", List.of("A", "B", "C")); returns "A.B.C"

String.join(".", List.of("HELLO")); returns "HELLO"




StringBuilder
--------------
- StringBuilder Constructors
1. StringBuilder(): Constructs a StringBuilder with no characters in it and an initial capacity of 16 characters.
2. StringBuilder(CharSequence seq): Constructs a StringBuilder that contains the same characters as the specified CharSequence.
3. StringBuilder(int capacity): Constructs a StringBuilder with no characters in it and an initial capacity specified by the capacity argument. If you expect to build a large string, you can specify a big capacity at the beginning to avoid reallocation of the internal storage array later.
4. StringBuilder(String str): Constructs a StringBuilder initialized to the contents of the specified string. This constructor is actually redundant because of the StringBuilder(CharSequence seq) constructor. It exists only for backward compatibility with code written before JDK 1.4, which is when CharSequence was first introduced.

- public StringBuilder append(). Appends the string representation of the argument to the sequence. Returns reference to the StringBuilder object.

- public StringBuilder insert(int offset, variousDataTypes b). Inserts the string representation of the argument into this sequence. Returns reference to the StringBuilder object. If offset > length or offset < 0 then StringIndexOutOfBoundException is thrown.

- If you pass a variable pointing to null, the string "null" is appended to or inserted in the existing StringBuilder. No NullPointerException is thrown.

- For everything else, String.valueOf( ... ) is invoked to generate a string representation of the argument that is passed. For example, String.valueOf(123) returns the String "123", which is then appended to or inserted in the existing StringBuilder. In case of objects, valueOf invokes toString() on that object to get its string representation.

- public StringBuilder reverse() returns a StringBuilder object in reversed order and modifies original object

- public StringBuilder replace(int start,int end, String str) replaces StringBuilder object with str starting at start(inclusive) and ending at end(exclusive) and returns modified StringBuilder object. Throws StringIndexOutOfBoundsException - if start is negative, greater than length(), or greater than end.

- public StringBuilder delete(int start,int end). Removes the characters in a substring of this sequence. The substring begins at the specified start and extends to the character at index end - 1 or to the end of the sequence if no such character exists. If start is equal to end, no changes are made. Throws StringIndexOutOfBoundsException - if start is negative, greater than length(), or greater than end.

- public StringBuilder deleteCharAt(int index). Removes the char at the specified position in this sequence. This sequence is shortened by one char. Throws StringIndexOutOfBoundsException - if the index is negative or greater than or equal to length().

- StringBuilder object will always maintain an addition buffer of 16 chars whenever a string is appended to the object. For eg
StringBuilder sb = new StringBuilder(); // capacity is 16;
StringBuilder sb = new StringBuilder("Dhruv"); // capacity is 21

- Methods that cannot be chained are 
int capacity() 
char charAt(int index) 
int length() 
int indexOf(String str) 
int indexOf(String str, int startIndex) 
void setLength(int len) 
String substring(int start) 
String substring(int start, int end) 
String toString()

Array in Java
-------------
- Array.mismatch(array1, array2) return zero based index of arrays where mismatch is found. mismatch function is
overloaded and it takes primitive data types only. boolean, char, byte, short, int, float, double.

- There are other overloaded mismatch methods for primitive types with ranges:

int mismatch​(primitiveDataType[] a, int aFromIndex, int aToIndex, primitiveDataType[] b, int bFromIndex, int bToIndex)
These methods also compares the arrays, but over the specified range. 'From' index is inclusive but 'To' index is exclusive. Please note that returned index is relative.

Range version of mismatch methods throw below exceptions:
NullPointerException: if either array is null
IllegalArgumentException: if aFromIndex > aToIndex or if bFromIndex > bToIndex
ArrayIndexOutOfBoundsException: if aFromIndex < 0 or aToIndex > a.length or if bFromIndex < 0 or bToIndex > b.length

- Array.compare(Array1, Array2), if any array (Array1, Array2) is a proper prefix of each other then function returns
Array1.length - Array2.length. If Array1 is not sub set of Array2, then each element of arrays are compared with rules
of compare method of their respective primitive types.

- Array.equals(array) returns true if both array are equal false otherwise.

- public method named clone. This method creates a copy of the array object. Note that it doesn't create copies of the objects referred to by the array elements. It merely creates a new array object of the same length and copies the contents of existing array into the new array. Which means, if the existing array contained primitive values, those values will be copied to the elements of the new array. If the existing array contained references to objects, those references will be copied to the elements of the new array. Thus, the elements of the new array will also point to the same objects. This is also known as "shallow copy".




