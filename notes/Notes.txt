Creating a Simple Java Program
-------------------------------
- It is possible to create multiple public class in one java file (single file program). But it must be executed by
java source_file.java command. This java file should contain first class defined have public static void main function.
And there is no requirement that this file should also have class defined by the name of java file.

- It also not a requirement for source.java need to have public class defined by source. But any first class defined in
a file should have psvm function if it were to be executed as single file program java source.java command.

- source.java file can have multiple classes defined which are not public and can be compiled by javac command. When complied
by javac command, it will create multiple .class files. Which can be executed by java xyz command, where xyz command line
option is xyz.class file generated by javac command

Working With Java Primitive Data Types and String APIs
------------------------------------------------------
- substring(int start, int to): start is inclusive, to in exclusive
- cannot use local variable without initializing it.
- toString method of StringBuilder class uses String constructor and does not use String literal. Hence when checked for
referential equality with literal it will always be false
- String.split(String pattern, int number). pattern is applied number - 1 times to string. e.g.
"BEVERAGE".split("E", 3). Pattern "E" is applied to BEVERAGE 3 - 1 = 2 times. Hence result of will be
array ["B", "V", "RAGE"]
- When using int variable to assign to short int variable has to be within short range and declared as final variable.
- When matching overloaded method with reference type method is always mapped to lowest class in hierarchy. If there are
two different non related classes then compiler will cause compilation error as compiler is not able to find method to
map a method.
- StringBuilder.append method is an overloaded method with form append(String) and append(StringBuffer). String and
StringBuffer is unrelated classes. So while passing null to append method, compiler has ambiguity in mapping right
method.
- String repeat(num) concatenate string 3 times.

MAIN OBSERVATIONS
-----------------
- Under standing impact of usage of final keyword
- Mapping of overloaded methods as per passed parameter
- String and String Builder api documentation


Using Operators and Decision Constructs (12 questions) -- 67%
--------------------------------------------------------------
- We can cast an object in a chain to its parent, grand parent and further with following syntax
((GreatGrandParentClass)(GrandParentClass)(ParentClass)childObject).childMemberOrMethod

- . has a higher precedence than parenthesis so (ParentClass)childObject.stringVal will try to convert
stringVal member variable to ParentClass with is not possible as ParentClass in not related to String class.
Hence compilation error is generated.

- Array mismatch return first position where a miss match is found (0 based). So if position is 3, then mismatch
method will return 3 - 1 = 2. mismatch return -1 if no mismatch is found and null pointer position if either array is
null

- compare(x, y) return results as below
char: x - y
byte: x - y
short: x - y
int: -1 if x < y, 1 if x > y, 0 if x == y
double: -1 if x < y, 1 if x > y, 0 if x == y
boolean: 1 if x == true && y == false, -1 if x == false && y == true, 0 if x == y

- String can point to null and use + operator to concatenate more string null objects. But cannot call methods
on a null pointing string object.

- if (expression1 && expression2 && expression3) . if expression1 evaluates to false, then expression2 and expression3
are not evaluated.

- with newer version of java switch statement can take String arguments as well

- Local variable Type inference was added in JDK 10 (var variables). var in not a keyword, hence var can be used
as variable name, method name, package name or loop label. But it cannot be used as class or interface name.

- String.join api reference

- For decision construct like in if, we can use wrapper Boolean class also.

MAIN OBSERVATIONS
-----------------
- silly mistakes


Working with Java Arrays (6 questions) -- 50%
---------------------------------------------
- Array.mismatch(array1, array2) return zero based index of arrays where mismatch is found. mismatch function is
overloaded and it takes primitive data types only. boolean, char, byte, short, int, float, double.

- Elements of arrays are always initialized to their respective zeros for primitive types or null for reference types

- Array.compare(Array1, Array2), if any array (Array1, Array2) is a proper prefix of each other then function returns
Array1.length - Array2.length. If Array1 is not sub set of Array2, then each element of arrays are compared with rules
of compare method of their respective primitive types.

- Declaration of type var[] variable_name is not allowed.
- Declaration of type var variable_name = {1, 2, 3} also not allowed as Explicit target-type is needed for the
array initializer. E.g. var variable_name = new int[]{1, 2, 3}


MAIN OBSERVATIONS
-----------------
- silly mistakes


Describing and Using Objects and Classes (1 question) -- 100%
-------------------------------------------------------------
- primitive type instance variables are initialized to their respective zeros and reference types to null
(char: \u0000, byte: 0, short: 0, int: 0, float: 0.0, double: 0.0, boolean: false)


Creating and Using Methods (5 questions) -- 80%
-----------------------------------------------
- non static member and methods cannot be accessed from static methods/static initializers




Applying Encapsulation (2 questions) -- 100%
--------------------------------------------
- access modifier in order from most to least restrictive private,
default (no access modifier specified with is package-private), protected, public

- if java file contains non public class and public class it will compile successfully. But non public class will
only be visible in its package only while public class is access anywhere (verify it).

Reusing Implementations Through Inheritance (6 questions) -- 67%
----------------------------------------------------------------
- Instance variable are hidden and not overridden by sub classes

- Dot operator has higher precedence than parentheses. e.g. (Parent)gc.quote will evaluate gc.quote first which is of
type String. Then (Parent) cast is evaluated, but quote (String) is not of type Parent hence it will lead to compilation
error.

- Chain of casting is also possible for subclass to super class. e.g ((Parent)(Child)gc).quote this expression will first
cast gc object to first Child and then to Parent object. Then Parent class quote member variable is referenced.

- Access modifier of overriding method should either be same as the access modifier of overridden method or it should
be less restrictive than the access modifier of overridden method.

- protected member variables can only be accessed in subclass using using inheritance but not using object reference
variable if a sub class is defined in different package. If sub class is defined in same package then protected, default
access modifier variable can be access via inheritance as well as through object reference.

- member variable inherited from super class can be access with this or super keyword.

- Constructors cannot use final, abstract or static modifiers

- sub class object is an instance of super class. Hence childClassObject instanceof Superclass returns true. But other
way round super class in not an instance of child class.

- If Super class reference variable points to sub class object. Then this variable will point to super class member
variable and sub class member methods.

- rules related to return types of overriding methods
A. If return type of overridden method is of primitive type, then overriding method should use same primitive type.
B. If return type of overridden method is of reference type, then overriding method can use same reference type or
its sub-type (also known as covariant return type).

- In case of overriding, if overridden method declares to throw any RuntimeException or Error, overriding method
may or may not throw any RuntimeException but overriding method must not throw any checked exceptions.

- In generics syntax, Parameterized types are not polymorphic, this means even if B is subtype of A,
List<B> is not subtype of List<A>. Remember this point. So below syntax are NOT allowed:

  List<A> list = new ArrayList<B>(); OR ArrayList<A> list = new ArrayList<B>();

- Another way/syntax to extend a class can be
ParentClass parentClass = new ParentClass() {
    // child class code
    };

- Static methods in Java are inherited, but can not be overridden. If you declare the same method in a subclass,
you hide the superclass method instead of overriding it. Static methods are not polymorphic. At the compile time,
the static method will be statically linked.


Programming Abstractly Through Interfaces (18 questions) -- 56%
---------------------------------------------------------------
- Arrays.asList method returns a fixed-size list backed by the specified array and as list is backed by the specified
array therefore, you cannot add or remove elements from this list. Using add/remove methods cause an
exception at runtime. But you can invoke the set(int index, E element) method on the returned list.

- List.of method, which returns unmodifiable list, hence calling add/remove/set methods on the unmodifiable list throws
an exception at runtime

- Iterable<T> interface has forEach(Consumer) method.  List<E> extends Collection<E> &
Collection<E> extends Iterable<E>, therefore forEach(Consumer) can easily be invoked on reference variable of
List<E> type.

- forEach(Consumer) method performs the given action for each element of the Iterable until all elements have been
processed or the action throws an exception. Consumer is a functional interface, hence a lambda expression can be
passed.

- abstract class in java can have 0 or more abstract methods

- methods in interface are by default abstract and abstract method cannot have a body. If we need to provide a
method with implementation, we need to declare that method with default or private keyword and
provide an implementation.

-clone method of list interface create a shallow copy of list object. Means if an original list contains reference
variables then after clone method a new list object is created which contains same reference objects as original
object.

- All wrapper classes Integer, Float, Double, Character, Byte, Short, Boolean are immutable classes like a String class.

- If lambda expression is in {}, then it should have complete expression including semicolons and return statement if
required.

- While implementing an interface method, this method should not have weaker access modifier than declared in interface.
Interface methods are public implicitly, so class which implements interface should also declare methods as public.

- Study ques40 for a very peculiar example of sub class implementing interface and extending base class which does not
implements any interface but has a same method implemented as its member method.

- Functional Interface can have only one non-overriding abstract method. Apart from it a functional interface can have
constant variables, default methods, private methods, overriding abstract methods.

- While traversing a list using an iterator, if it is required to remove item from list use Iterator.remove or
ListIterator.remove method, rather than List.remove method. As later method will throw
java.util.ConcurrentModificationException.

- Variables defined in interface are implicitly public final static. Correct way of access interface variable is with
syntax InterfaceName.variableName. But reference type can also point to interface variables.

- remove(Object o) method of list return true if object was removed successfully or false otherwise.

- remove(int index) remove the element of list at index and returns that element.

- add(E e) method of list return true if object was added successfully or false otherwise.
- add(int index, E element) inserts element at index. It returns void. if index is < 0 or > list length, then
IndexOutOfBound exception is thrown.


MAIN OBSERVATIONS
-----------------
- under stand list api functions


Handling Exceptions (8 questions) -- 63%
----------------------------------------

- In exception handling order in which catch block is specified matter. if subclass exception is specified after super
class exception, then it will be a compile error.

- RuntimeException can be thrown without any need to be declared in throws clause of surrounding method.
throw (RuntimeException)e;` doesn't cause any compilation error. Even though variable 'e' is type casted to
RuntimeException but exception object is still of ArithmeticException, which is caught in main method and
'AE' is printed to the console. (Ques 6)

- Java doesn't allow to catch specific checked exceptions if these are not thrown by the statements inside try block.

- If an instance of Exception is thrown by the catch-block but another catch-block at the same level are not executed.
Explaining this point further, in a try catch block with multiple catch blocks only one of the catch block is executed
even though an executed catch block throws new other type of exception. And as usual finally block is always executed.

- If a method has a throws clause and it throws unchecked exception then calling method don't need to handle that
exception. But if method throws checked exception then calling method needs to handle that exception by either
try/catch block or add throws clause to method signature.

- Hierarchy of Exception framework
java.lang.Throwable (Root of all exception classes, is covered under checked exception)

Checked Exceptions
------------------
java.lang.Exceptions (Extends java.lang.Throwable)
some subclasses
> java.io.IOException
> java.sql.SQLException

Unchecked Exceptions
--------------------
java.lang.Error (Extends java.lang.Throwable)
some subclasses
> java.lang.AssertionError
> OutOfMemoryError
> java.lang.StackOverflowError

java.lang.RuntimeException
some subclasses
> java.lang.NullPointerException
> java.lang.ArrayIndexOutOfBoundsException
> java.lang.ArithmeticException
> java.lang.ClassCastException

MAIN OBSERVATIONS
-----------------
- under stand exception framework hierarchy

Understanding Modules (8 questions) --50%
------------------------------------------
- command to compile modules
javac -d <output_directory> -p <module_path> --module-source-path <root_source_directory> -m <modules_to_compile>
 -p option can also be provided as --module-path
 -m option can also be provided as --module
-d <output_directory>: directory where compiled module will be placed
-p <module_path>: list of path separated by ; on windows and : on linux/mac which contains various modules which may be
required during the compilation of <module_to_compile>
--module-source-path <root_source_directory>: root source directory where all modules are kept
-m <module_to_compile>: name of module directory to compile. Multiple modules are separated by commas
NOTE: -p option is not required if a module to compile does not require any external module to refer during compilation
Type of module that can be referred by -p option: singlemodules, exploded modules, modular jar

- command to execute modules
java -p <module_path> -m <module>[/<mainclass>] [args...]
 -p option can also be provided as --module-path
 -m option can also be provided as --module
module_path(s) are separated by ; on windows and : on linux/mac
if each different module paths contain same module in them then first module path containing the requested module
is executed and other module paths are ignored. (see question 12). -m option should be the last option as it could
contain command line options.

- exploded module is module with its own directory structure and class file. In exploded module main class is
not optional.

- some of valid module directives
 exports
 requires
 requires transitive
a module cannot export standard module of java platform e.g. java.se

- requires transitive: Implied readability is to specify a transitive dependency on another module such that other
modules reading your module also read that dependency.
For example, if module C has `requires B;` (C reads B) and module B has `requires A;` (B reads A),
then C doesn't read A.

To have the transitive readability, 'requires transitive' directive is used. If module C has `requires B;`
(C reads B) and module B has `requires transitive A;` (B reads A [transitive dependency]), then C will also read A.

- export module to specific modules
exports <package_name> to <comma_separated_list_of_modules>;
if to <comma_separated_list_of_modules> is missing then package is exports to all modules
Also note that having multiple exports directive for same package is note allowed,
below code causes compilation error:

exports com.udayankhattry.books to bookhouse;
exports com.udayankhattry.books to onlinestore;
but instead it should be
exports com.udayankhattry.books to bookhouse, onlinestore;

- A module is a set of packages and all the classes should be part of some package (not the default package).
unnamed package is not allowed in named modules (see question 35)

- In module-info.java name of module should be same as its root directory

- Java Platform Module System was introduced in Java 9 as project jigsaw







Current read
------------
All done
