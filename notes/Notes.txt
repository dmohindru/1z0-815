Understanding Java Technology
------------------------------
- JDK 11 allow to create a class in default package (with missing package statement)

Creating a Simple Java Program
-------------------------------
- It is possible to create multiple public class in one java file (single file program). But it must be executed by
java source_file.java command. This java file should contain first class defined have public static void main function.
And there is no requirement that this file should also have class defined by the name of java file.

- It also not a requirement for source.java need to have public class defined by source. But any first class defined in
a file should have psvm function if it were to be executed as single file program java source.java command.

- source.java file can have multiple classes defined which are not public and can be compiled by javac command. When complied
by javac command, it will create multiple .class files. Which can be executed by java xyz command, where xyz command line
option is xyz.class file generated by javac command

- final modifier can be used with this special main method.

- Use -d option with javac command. -d option is used to specify where to place generated class files. For java files relative path to
file can be given

- To run a java program with a particular version of java use command as follow
java --source 11 Test.java . Instructs the java command to process the Test.java file as Java 11 source code other options can be 11, 10, 9, 8

- Starting with JDK 11, it is possible to launch single-file source-code Programs. 

- class name can start with $ or _

- class can have many main overloaded methods but only method with signature public static void main(String[] args) will be executed by JVM.

- order of public and static is interchangable e.g below are legal decleration for main method
public static void main(String[] args);
static public void main(String[] args);

- If you pass a file name with .java extension to java command, then java command consider the passed file as 'single-file source-code program'. But if any other file name is passed, then it considers the passed file as the class name. So, in this case, if you run the command `java Util.txt 10 20`, then java command searches for the class with the name 'Util.txt' and would thrown an error. If the file does not have the .java extension, the --source option must be used to force source-file mode.
`java --source 11 Util.txt 10 20` instructs the java command to process the Util.txt as Java 11 source code. 
 
Working With Java Primitive Data Types and String APIs
------------------------------------------------------
- long and int can be assigned to float and double without any casting.
- substring(int start, int to): start is inclusive, to is exclusive
- cannot use local variable without initializing it.
- toString method of StringBuilder class uses String constructor and does not use String literal. Hence when checked for
referential equality with literal it will always be false
- String.split(String pattern, int number). pattern is applied number - 1 times to string. e.g.
"BEVERAGE".split("E", 3). Pattern "E" is applied to BEVERAGE 3 - 1 = 2 times. Hence result of will be
array ["B", "V", "RAGE"]
- When using int variable to assign to short int variable has to be within short range and declared as final variable.
- When matching overloaded method with reference type method is always mapped to lowest class in hierarchy. If there are
two different non related classes then compiler will cause compilation error as compiler is not able to find method to
map a method.
- StringBuilder.append method is an overloaded method with form append(String) and append(StringBuffer). String and
StringBuffer is unrelated classes. So while passing null to append method, compiler has ambiguity in mapping right
method.
- String repeat(num) concatenate string num times.
- int var = (var = Test.var.length()); this type of statement is a valid statement.
- String and StringBuilder classes override toString() method, which prints the text stored in these classes.
- Compound declarations are allowed in Java for primitive type and reference type but not for var type.
Therefore following statement is a valid statement
int x = 7, y = 8; or float x = 7, y = 8;
and following statement is invalid statement
var x = 7, y = 8;

- Local variable Type inference was added in JDK 10 (var).
- var x = "Java"; //x infers to String
- var m = 10; //m infers to int
- casting wider primitive data type to narrower data type is possible in java as in C or other language. 
eg. byte b = (byte) 100000; would take eight bit value from 100000 and store in byte b.

- As String are immutable type. So if a String object is passed to a method with modifies that String object. Then the original String is not
modified but a new String object is created. So if that method does not returns this modified String object then original String object is not modified
and a newly created String object becomes eligible for garbage collection.

- You need to keep in mind an important point related to String Concatenation:
If only one operand expression is of type String, then string conversion is performed on the other operand to produce a string at run time.
If one of the operand is null, it is converted to the string "null".
If operand is not null, then the conversion is performed as if by an invocation of the toString method of the referenced object with no arguments; but if the result of invoking the toString method is null, then the string "null" is used instead.

- While concating an object with String, an objects toString() method is called.

- String class implements CharSequence. Hence reference variable of type CharSequence can point to String objects.

- Please note that Strings computed by concatenation at compile time, will be referred by String Pool during execution. Compile time String concatenation happens when both of the operands are compile time constants, such as literal, final variable etc.
Whereas, Strings computed by concatenation at run time (if the resultant expression is not constant expression) are newly created and therefore distinct.

- (num++ == num++) // will result in false. say initial value of num = 10
(10 == num++) //Left side operand is evaluated first, value 10 is used in the expression and variable num is incremented by 1, so num=11
(10 == 11) //Right side operand is evaluated next, value 11 is used in the expression and variable num is incremented by 1, so num = 12

- var type cannot be used as method parameters or method return type. Local variable Type inference (var) is applicable only for local variables and not for instance or class variables. var cannot be used for lambda target type variable. 

- Syntax of labels used in java loops
one: for (var i = 0; i < 10; i++) {
two: for (var j = 0; j < 7; j++) {
three: while (true) { } } }

- initalizing a variable in if else if block based on test on variable value will cause compilation error.
double price = 90000;
String model;
if(price > 100000) {
	model = "Tesla Model X";
} else if(price <= 100000) {
	model = "Tesla Model S";
}
System.out.println(model); 
only way initialization in if else block will succeed when there is sure shot initializing happening.

- Please note that Strings computed by concatenation at compile time, will be referred by String Pool during execution. Compile time String concatenation happens when both of the operands are compile time constants, such as literal, final variable etc (variable have to be primitive type or String type, wrapper classes don't count in compile time constant).
Whereas, Strings computed by concatenation at run time (if the resultant expression is not constant expression) are newly created and therefore distinct.

- var a = (int)x + (int)y; //This is a valid java statement

- var cannot be used without initalizer
var num;
num = 10; // compile time error

- var num = null; // won't compile as type cannot be inferred from null

- observe the following statement important
int i = -2;
i = -(--i); // will result in 3
i = -(++i); // will result in 1 can also be written as -++i

- wrapper classes overrides equals method

- Wrapper class == works by unboxing and checking its value. But one exception is when unboxing with Integer as demonstrated by below code
// If value of Integer is between -128 to 127 below code will print true else it will print false
Integer i1 = Integer.valueOf(4);
Ingeter i2 = 4;
System.out.println(i1 == i2); // prints true

Integer i1 = Integer.valueOf(128);
Ingeter i2 = 128;
System.out.println(i1 == i2); // prints false

- any number of underscore can come between digits, but not before or after number. e.g.
int i = 1___2_3; // ok
int i = ____1; // not ok as literal value but ok with variable name
int i = 1____; // not ok
_ cannot be around decimal point or after number and before f literal
float f = 12_3.0_1f; // ok
float f = 1230_.01f; // not ok
float f = 1230._01f; // not ok
float f = _1230.01f; // not ok
float f = 1230.01_f; // not ok

- float i = 100.0; // fails to compile as compiler assume 100.0 as double so to compile it properly we need to do following adjustments
float i = 100.0f; or float i = (float)100.0;
System.out.println(i); //will print 100.0 by default and not 100.00 -- important remember

- Below code will generate compilation error because of usage of uninitialized variable
public class Test {
    static String str = "KEEP IT "; //Line n1
    public static void main(String[] args) {
        String str = str + "SIMPLE"; //Line n2
        System.out.println(str);
    }
}

- underscore '_' can be used to increase readability by we cannot use _ for following situtations
Beginning and end of number
Adjacent to a decimal point in floating-point literal
prior to suffix

- Strings computed by concatenation at compile time, will be referred by String Pool during execution. Compile time String concatenation happens when both of the operands are compile time constants, such as literal, final variable of primitive type or String type.




MAIN OBSERVATIONS
-----------------
- Under standing impact of usage of final keyword
- Mapping of overloaded methods as per passed parameter
- String and String Builder api documentation


Using Operators and Decision Constructs (12 questions) -- 67%
--------------------------------------------------------------
- We can cast an object in a chain to its parent, grand parent and further with following syntax
((GreatGrandParentClass)(GrandParentClass)(ParentClass)childObject).childMemberOrMethod

- . has a higher precedence than parenthesis so (ParentClass)childObject.stringVal will try to convert stringVal member variable to ParentClass with is not possible as ParentClass in not related to String class.
Hence compilation error is generated.

- Array mismatch return first position where a miss match is found (0 based). So if position is 3, then mismatch method will return 3 - 1 = 2. mismatch return -1 if no mismatch is found and NullPointerException is thrown if either array is null.

- compare(x, y) return results as below
char: x - y
byte: x - y
short: x - y
int: -1 if x < y, 1 if x > y, 0 if x == y
double: -1 if x < y, 1 if x > y, 0 if x == y
boolean: 1 if x == true && y == false, -1 if x == false && y == true, 0 if x == y

- String can point to null and use + operator to concatenate more string null objects. But cannot call methods on a null pointing string object.

- if (expression1 && expression2 && expression3) . if expression1 evaluates to false, then expression2 and expression3
are not evaluated.

- with newer version of java switch statement can take String arguments as well

- Local variable Type inference was added in JDK 10 (var variables). var in not a keyword, hence var can be used as variable name, method name, package name or loop label. But it cannot be used as class or interface name.

- String.join api reference

- For decision construct like in if, we can use wrapper Boolean class also. But if Boolean type variable is uninitialized to null, it will throw NullPointerException if used in if construct.

- if switch construct have default clause stated on top of other case clause and if no case statement is matched then default will be executed and fall
through all case statement if no break statement is encountered in the path.

- do while loop with continue statement.

- Following statement results in a compile-time error:
while (false) { x=3; }
because the statement x=3; is not reachable; but the superficially similar case:
if (false) { x=3; }
does not result in a compile-time error. An optimizing compiler may realize that the statement x=3; will never be executed and may choose to omit the code for that statement from the generated class file, but the statement x=3; is not regarded as "unreachable" in the technical sense specified here.

- statement -val returns negative value of val but does not modifies original value of val.

- //Postfix operator has higher precedence than other available operators 
e.g. -val-- would evaluate as -(val--) what this expression does it get the value of val, return its negated value and then decrement value of val by 1. So if val = 9, then above expression would return -9 and after evaluating this expression value of val is 8.
e.g. -(++val) what this expression does it get the value of val, increment it by one and return its negated value. 
So if val = 9, then above expression would return -10 and after evaluating this expression value of val is 10 

- byte val = 127;
val = val + 1; // result in int does not compile
val = val - 1; // result in int does not compile
val++; // result val = (byte)(val + 1) compiles ok
val--; // result val = (byte)(val - 1) compiles ok
val *= 2; // result in val = (byte)(val*2); compile ok
val -= 10; // results in val = (byte)(val - 10); compiles ok

- for loop labels keywords cannot be used like for, while etc.

- Binary plus (+) has got higher precedence than != operator.

- switch can accept primitive types: byte, short, int, char; wrapper types: Byte, Short, Integer, Character; String and enums. In this case long and double are invalid values to be passed in switch expression.

- below code generates compile error as unreachable code
  public static void main(String[] args) {
  do {
  System.out.print(100);
  } while (true); //Line n1      
  System.out.println(200); //Line n2
  }
  
- char var = 7; // is a valid statement
char var = 8; and char var = '8'; // var store two different values
int ch = 'z'; // is a valid statement

- Wrapper class are not related to each other and cannot be assigned to each other. e.g.
Integer i = 10;
Byte b = 10;
i = b; // will cause compilation error
where as below code will not cause any error
int i = 10;
byte b = 10;
i = b;

- ! has higher precidence than && operator and && operator has higher precidence than || operator.

- assignment operator += *= -= /= has least precedence. 



MAIN OBSERVATIONS
-----------------
- silly mistakes


Working with Java Arrays (6 questions) -- 50%
---------------------------------------------
- Array.mismatch(array1, array2) return zero based index of arrays where mismatch is found. mismatch function is
overloaded and it takes primitive data types only. boolean, char, byte, short, int, float, double.

- Elements of arrays are always initialized to their respective zeros for primitive types or null for reference types

- Array.compare(Array1, Array2), if any array (Array1, Array2) is a proper prefix of each other then function returns
Array1.length - Array2.length. If Array1 is not sub set of Array2, then each element of arrays are compared with rules
of compare method of their respective primitive types.

- Declaration of type var[] variable_name is not allowed.
- Declaration of type var variable_name = {1, 2, 3} also not allowed as Explicit target-type is needed for the
array initializer. E.g. var variable_name = new int[]{1, 2, 3}

- int [] arr1 = new int[8]; Creates one-dimensional array object to store 8 elements and arr1 refers to it. This statement compiles without any error.

- int [][] arr2 = new int[8][8]; Creates two-dimensional array object to store 8 * 8 = 64 elements. This statement also compiles fine.

- int [] arr3 [] = new int[8][]; Creates two-dimensional array object, whose 1st dimension is 8 but 2nd dimension is not yet defined. On the left side array symbols can be used before the reference variable or after the reference variable or can be mixed, hence int [][] arr3, int [] arr3 [] and int arr3[][] all are valid. This statement compiles successfully.

- int arr4[][] = new int[][8];: 1st array dimension must be specified at the time of declaration. new int[][8]; causes compilation error as 1st dimension is not specified.

- Legal ways to declare arrays
One dimensional array
int[] a, int a[]
two dimensional array
int[][] a, int[] a[], int a[][]

- Legal ways of using array initalizers
int[] ia = {1, 2, 3, 4, 5};
int[] ia = new int[]{ 1, 2, 3, 4, 5 };
int[] ia = new int[2]{ 1, 2 };//will not compile.

Object[] obj = {new Object(), new Object()};
Object[] obj = new Object[] {new Object(), new Object()};
Object[] obj = new Object[2] {new Object(), new Object()}; //will not compile

- Legal ways for using allocated and uninitalized array
int[] ia = new int[2];
Object[] obj = new Object[2];

- Legal ways for using multi-dimentional array initalizer
int[][] iaa = new int[2][3];
int[][] iaa = new int[3][];
int[][] iaa = new int[][]{ new int[]{ 1, 2 }, new int[]{ 3, 4 } }; is same as int[][] iaa = { { 1, 2 }, {3, 4 };
Object[] obj[] =  { {"string is also an object"}, {null } , { new Object() , new Integer(10)} }; 
 
- Be very observant about question asking you what options to choose so that program compiles only and not cause runtime exception. Or program that compiles
and executes successfully. These two question would have different answers. 

- array variable are incompatible with each other even though its base data type are compatible.
e.g int[] intArray; long[] longArray;
longArray = intArray; // incompatible type will not compile
long longVar; int intVar;
longVar = intVar; // compatible type will compile without any issue.

- cannot declare array as 
var arr2 = {1, 2, 3}; // its compile time error
var arr2 = new int[]{1, 2, 3}; // this compiles fine

int[] array = new int[4];
array.toString(); // this would return string describe array something like this '[I@5674cd4d'

- its is not possible to assign array on one primitive type to other primitive type, but is possible in class of reference type if one reference has is-a relation ship with each other. e.g.
var intArray = new int[5];
var shortArray = new short[3];
intArray = shortArray; // will cause compilation error

- There will be no compilation error if array is initialized with negative index e.g.
int [][]arry = new int[-1][-2]  
----
var objArray = new Object[3];
var strArray = new String[2];
var sbArray = new StringBuilder[6];
objArray = strArray; // will compile fine
strArray = sbArray; // will not compile
strArray = objArray; // will not compile

- for Arrays.compare function
String [] array1 = {"OCP", "11", null};
String [] array2 = {"OCP", "11"};
String [] array3 = {null, "OCP", "11"};

array2 is a proper prefix of array1, but array2 is not a proper prefix of array3


MAIN OBSERVATIONS
-----------------
- silly mistakes


Describing and Using Objects and Classes (1 question) -- 100%
-------------------------------------------------------------
- primitive type instance variables are initialized to their respective zeros and reference types to null
(char: \u0000, byte: 0, short: 0, int: 0, float: 0.0, double: 0.0, boolean: false). And when char which points to \u0000 is printed it not print anything on console.

- very important var cannot be used at class member variable.




Creating and Using Methods (5 questions) -- 80%
-----------------------------------------------
- non static member and methods cannot be accessed from static methods/static initializers

- Class name and method name can be same and that is why given method can be declared in any of the given classes: emp, Emp, employee, Employee, Student and _emp_. _emp_ is also a valid Java identifier. Hence class name can start with _ character.

- this(arguments); syntax is used to call one constructor from other constructor. 

- variable in methods cannot be declared private or protected.

- Method selection for overloaded message
1. The first rule is that having overloaded methods does not cause a compilation error by itself. In other words, as long as their method signatures are different, the compiler doesn't care whether they are too similar or not. Compilation error occurs only if the compiler is not able to successfully disambiguate a particular method call.

2. Exact match - If the compiler finds a method whose parameter list is an exact match to the argument list of the method call, then it selects that method. For example, consider the following two methods: 
void processData(Object obj){ }
void processData(String str){ } 
and the method call processData("hello");. Since String is an Object, the String argument matches the parameter list of both the methods and so both the methods are capable of accepting the method call. However, String is an exact match to the argument and so the compiler will select the second method. 
This rule applies to primitives as well. Thus, out of the following two methods, the first method is selected when you call processData(10); because 10 is an int, which matches exactly to the parameter type of the first method even though the long version of the method is also perfectly capable of accepting the value. 
void processData(int value){ }
void processData(long value){ } 

3. Most specific method - If more than one method is capable of accepting a method call and none of them is an exact match, the one that is "most specific" is chosen by the compiler. For example, consider the following two methods: 
void processData(Object obj){ }
void processData(CharSequence str){ } 
and the method call processData("hello");. Remember that String extends CharSequence and CharSequence extends Object. Thus, a String is a CharSequence and a String is also an Object. So here, neither of the methods has a parameter list that is an exact match to the type of the argument but both the methods are capable of accepting a String. However, between Object and ChareSequence, CharSequence is more specific and so the compiler will select the second method.

Since primitives are not classes, there is no subclass/superclass kind of relation between them as such but Java does define the subtype relation for them explicitly, which is as follows: 
double > float > long > int > char 
and 
int > short > byte 
What it means is, float is a subtype of double, long is a subtype of float, int is a subtype of long, and char is subtype of int. And also, short is a subtype of int and byte is a subtype of short. Based on the above, you can easily determine which of the following two methods will be picked if you call processData((byte) 10);
void processData(int value){ }
void processData(short value){ } 
The short version will be picked because short is a subtype of int and is therefore, more specific than an int.

4. Consider widening before autoboxing - Since autoboxing only came into existence when Java 5 was released, it is necessary to give higher priority to the primitive versions if the argument can be widened to the method parameter type so that existing code will keep working as before. Therefore, out of the following two methods, the short version will be picked instead of the Byte version if you call processData( (byte) b); even though the Byte version is an exact match with byte after autoboxing.
void processData(short value){ }
void processData(Byte value){ } 

5. Consider autoboxing before varargs - This rule mandates that if an argument can be autoboxed into a method parameter type then that method be considered even if a method with varargs of the same type is available. This explains why if you call processData(10); then the Integer version (and not the int... version) is picked out of the following two. 
void processData(int... values){ }
void processData(Integer value){ }  

- Please note that there is no rule regarding return type for overloaded methods, return type can be same or different.

- for given overloaded method
int calculate(int i1, int i2) { return i1 + i2;}
double calculate(byte b1, byte b2) { return b1 % b2; }
int i = 9;
byte b = 100;
calculate(b, i); // this call will tag to calculate(int, int) as byte is implicitly casted to int type.

- its legal but not a prefered way to access static variable of class through this keyword.



Applying Encapsulation (2 questions) -- 100%
--------------------------------------------
- access modifier in order from most to least restrictive private, default (no access modifier specified with is package-private), protected, public

- if java file contains non public class and public class it will compile successfully. But non public class will
only be visible in its package only while public class is access anywhere (verify it).

- public members of default access modifier class. cannot be access from outside of current package 


Reusing Implementations Through Inheritance (6 questions) -- 67%
----------------------------------------------------------------
- Instance variable are hidden and not overridden by sub classes. There is no rules related to hiding (type and access modifier can be changed).

- Dot operator has higher precedence than parentheses. e.g. (Parent)gc.quote will evaluate gc.quote first which is of
type String. Then (Parent) cast is evaluated, but quote (String) is not of type Parent hence it will lead to compilation
error.

- Java compiler adds super(); as the first statement inside constructor, if call to another constructor using this(...) or super(...) is not available. If a super class has defined any constructor with arguments and has not defined no-arg constructor, then call to super() will fail. 

- Chain of casting is also possible for subclass to super class. e.g ((Parent)(Child)gc).quote this expression will first
cast gc object to first Child and then to Parent object. Then Parent class quote member variable is referenced.

- Access modifier of overriding method should either be same as the access modifier of overridden method or it should
be less restrictive than the access modifier of overridden method.

- An overriding method cannot put a wider exception (i.e. a superclass exception) in its throws clause than the ones present in the throws clause of the overridden method. For example, if the overridden method throws IOException, the overriding method cannot throw Exception because Exception is a superclass of IOException. 

- In a sub class you cannot override a static method as instance method or instance method as static method.

- protected member variables can only be accessed in subclass using using inheritance but not using object reference
variable if a sub class is defined in different package. If sub class is defined in same package then protected, default
access modifier variable can be access via inheritance as well as through object reference.

- member variable inherited from super class can be access with this or super keyword.

- Constructors cannot use final, abstract or static modifiers

- sub class constructor cannot have both super() or this() in them. It has to either of two, as call to super() or this() has to be first statement in sub class constructor

- abstract methods cannot be private, final and static

- Using static and final in methods are redundant. When a static method is overridden in a subclass it can still be accessed via the super class, making a final declaration not very necessary. Declaring a static method final does prevent subclasses from defining a static method with the same signature.

- sub class object is an instance of super class. Hence childClassObject instanceof Superclass returns true. But other
way round super class in not an instance of child class.

- If Super class reference variable points to sub class object. Then this variable will point to super class member
variable and sub class non-static member methods.

- If an interface reference variable points to sub class object (Which implements this interface). Then this variable will point to interface static member
variable and sub class member methods.

- rules related to return types of overriding methods
A. If return type of overridden method is of primitive type, then overriding method should use same primitive type.
B. If return type of overridden method is of reference type, then overriding method can use same reference type or
its sub-type (also known as covariant return type).

- In case of overriding, if overridden method declares to throw any RuntimeException or Error, overriding method
may or may not throw any RuntimeException but overriding method must not throw any checked exceptions.

- In generics syntax, Parameterized types are not polymorphic, this means even if B is subtype of A,
List<B> is not subtype of List<A>. Remember this point. So below syntax are NOT allowed:

  List<A> list = new ArrayList<B>(); OR ArrayList<A> list = new ArrayList<B>();

- Another way/syntax to extend a class can be
ParentClass parentClass = new ParentClass() {
    // child class code
    };

- Static methods in Java are inherited, but can not be overridden. If you declare the same method in a subclass, you hide the superclass method instead of overriding it. Static methods are not polymorphic. At the compile time, the static method will be statically linked.

- If a super class reference variable points to subclass object then it is legal to cast super class variable to sub class variable, although it is redundant.
eg. X --> Y --> Z
X x = new Z();
(Y)x; // legal and will compile even though its redundant
(Z)x; // legal and will compile even though its redundant

- ClassCastException is thrown if two super class reference variable point to sibling child classes if one sibling object is converted to other sibling object using a super class variable then ClassCastException is thrown.
eg. A-->B, A-->C
A a1 = new B();
A a2 = new C();
C c1 = (C)a1; // will compile fine but will throw ClassCastException.

- private or protected modifier cannot be used at class level

- Even though class is declared public but if its constructor is declared with default modifier (package private) we will not be able to inherit from that
class in other package or even instantiate that class.

- Order of initalizers summarized
A --> B (B is sub class of A)
1. static initializers of A and B are invoked before B's main() is executed because the JVM needs to load the class before it can invoke a method on it.
2. Static initializers of A and B are invoked only once even though two objects of B are created.
3. Instance initializer of A is executed before A's constructor even though the instance initializer appears after the constructor in A's code.
4. While creating an object of B, A's instance initializer and constructor are invoked before B's instance initializer and constructor.
5. Instance initializer and constructor of A are invoked each time an object of B is created.

- Summary of the application of access modifiers, final, abstract, and static keywords
1. An abstract class doesn't necessarily have to have an abstract method but if a class has an abstract method, it must be declared abstract. In other words, a concrete class cannot have an abstract method.
2. An abstract class cannot be instantiated irrespective of whether it has an abstract method or not.
3. A final class or a final method cannot be abstract.
4. A final class cannot contain an abstract method but an abstract class may contain a final method.
5. A private method is always final. 
6. A private method can never be abstract.
7. A static method can be final but can never be abstract.

- you can cast any type of reference to any interface. That's true except in one case. If the declared class of the variable is final and if that class does not implement the interface given in the cast, the compiler knows that this class can never have any subclass and therefore, it knows that there is no way the reference can point to an object of a class that extends this class and also implements the given interface. For example, String is a final class and the following code will not compile for the same reason: 
String s = new String();
Poisonous p = (Poisonous) s; //will not compile
But you cannot cast unrelated class objects to each other.
StringBuilder sb = (StringBuilder) new String("Hello World!); // will not compile

- You need casting when you want to use the features (i.e. instance variables and methods) defined in a subclass using a reference whose declared type is of a superclass.

-  static methods, static variables, and instance variables are accessed as per the declared type of the variable through which they are accessed and not according to the actual type of the object to which the variable refers. Same rule applies for interface variables also.

- There are different ways in which static method of an abstract class can be accessed:
(Abstract class) A --> MyClass
1. By using the name of the abstract class: A.log(); //Preferred way
2. By using the reference variable of abstract class: A o1 = null; o1.log();
3. By using the name of the subclass: MyClass.log();
4. By using the reference variable of the subclass: MyClass o2 = null; o2.log();

- when instanceof is used on unrelated classes its causes compilation error. The compiler will let you use instanceof operator only if it is possible for the variable to refer to an object of the type given on the right-hand side. For example, f instanceof Mango is valid because the compiler knows that the declared type of f is Fruit and since Mango is a Fruit, it is possible for f to point to a Mango. But f instanceof String will not compile because the compiler knows that there is no way f can ever point to a String.

- An abstract child sub class can declare non-abstract overriding method of super class as abstract.

- Child class can extend a concrete class and still be declared abstract.

- Even if instance variable initializers are present in class, instance variable will only be initalized after a call to super method is executed. (Test 4 - Ques 22).  

- Any super class reference variable can be casted to sub class reference variable no compilation error. But if super class reference variable points to super class object then it will cause ClassCastException, if super class reference point to null or sub class object then it will not throw any exception.
e.g. Base --> Sub
Base b = new Base();
Sub s = (Sub)b; // will compile fine but will cause ClassCastException at run time
------
Base b = null;
Sub s = (Sub)b; // will compile fine and will not throw any exception at run time

- super.super is not allowed in java, it causes compilation error. In fact, it is not possible to directly reach to 2 levels, super keyword allows to access methods and variables of immediate parent class only (just 1 level up).

- casting of super or this keyword in not allowed 

- Assignment like Object num = 10; will autobox 10 to Integer type as assign it to num reference variable.

- If super class reference variable is used to point to sub class object. Then through super class variable only those member function can be invoked which are defined in super class. 

- Constructors cannot use final, abstract or static modifiers. 


Programming Abstractly Through Interfaces (18 questions) -- 56%
---------------------------------------------------------------
- Interface methods are always public and abstract implicitly method. You don't have to specify abstract keyword.

- Interface fields cannot be protected or private. All variables defined in an interface are implicitly public, static, and final. 

- default methods are just the opposite of abstract methods. They are defined using the keyword default. Default methods are always public even if you do not declare them as such explicitly. You cannot mark them private or protected. default methods are part of object (Class instance)

- static methods - As the name implies, static methods belong to the interface itself and not to the object implementing that interface. They are defined using the keyword static. Static methods can be marked public or private but not protected. If no access modifier is specified, they are implicitly public. Static methods cannot be marked default either. static methods are not inherited but always remain part of interface only.

- Static methods of interface can only be invoked only as InterfaceName.nameOfStaticMethod(); and not by instance of class implementing the interface.

- Though correct way to refer static variable is by using the type name, such as Counter.count but it can also be invoked by using Counter reference variable.

- If a subclass extends from a class and implements an interface, and both super class and interface have method with same signature (interface has default method), then subclass will inherit super class method and not interface method. 

- Private methods (static as well as no-static) have been allowed since Java 9 and, as explained above, they are helpful when a default and static methods gets too big and needs to be refactored into smaller internal methods without exposing the internal methods to the outside world.

- Since methods of an interface are meant to be implemented by the classes that implement the interface, methods of an interface cannot be declared final.

- methods in interface are by default abstract and abstract method cannot have a body. If we need to provide a method with implementation, we need to declare that method with default or private keyword and provide an implementation.

- Syntax of class implementing multiple interfaces as class MyClass implements Interface1, Interface2 {}

- it is possible for a class to inherit multiple implementations of a default method from more than one interface.  JVM will have ambiguity which method to invoke on than object. So Java resolves this problem by forcing the class to provide an implementation of the method of its own to remove the ambiguity in invocation.  

- above rule also valid if one interface have default method and other has abstract method with same signature.

- In Interfaces Java allows a class to inherit multiple fields from interface(s) with the same name as long as you don't try to use those fields ambiguously. To remove ambiguity use fields with their Interface name. e.g. Interface1.myVar and Interface2.myVar

- Syntax for interface to extend interface
single interface: interface Interface2 extends Interface1 {}
multiple interface: interface Interface3 extends Interface1, Interface2, OtherInterface {}

- Remember that a class cannot extend an interface, it can only implement an interface. Whereas, an interface cannot implement any interface it can only extend an interface. 

- If an interface inherit two default methods or one abstract and other default method with same signature, then the inheriting interface should provide its own implementation of default method (like than in class) else it will be a compile error.

- If two or more super interfaces have abstract method with same name, so inheriting interface will get only one copy of abstract method and hence class implementing that interface will have to provide only one implementation of that abstract method. 

- Static fields of an interface are inherited by a sub interface and therefore ReadWritable does get two versions of SIZE variable. Java allows an interface to inherit multiple fields with the same name as long as you don't try to use those fields ambiguously. 
  
- Inheriting interface can provide implementation of abstract methods inherited from its super interface.

- To use local variables in functional interface implementation a variable should be final or effectively final, else compilation error will occur.

- Since, due to type erasure, generic information is removed at run time, it follows that generic information cannot be a part of the signature. Thus, two methods that differ only in their type parameters are not valid overloads.

- Read about writing generic class

- Read about writing generic methods	

- Generics were added quite late to Java (only in 1.5) and so backward compatibility was an important concern. Furthermore, since it was a fairly complicated feature, it was expected that their wide spread usage will take some time. Thus, it was deemed necessary that code that uses Generics must work with code that doesn't use Generics. To achieve this design goal, the mechanism of type erasure was used, where all the generic information is stripped from a class at run time. Thus, even if you write ArrayList<String> al = new ArrayList<>(); in your code, the JVM will only see ArrayList al = new ArrayList();. The type information is effectively "erased" from a class for the JVM.

- Since, due to type erasure, generic information is removed at run time, it follows that generic information cannot be a part of the signature. Thus, two methods that differ only in their type parameters are not valid overloads.

- Even though due to erasure, generic information is removed at run, this would result of valid override even if types are different. But java will not allow a code to compile if type information are different in overriding methods. In other word for a valid overriding methods should have same type for generic parameters.
eg.
class A { void processData(List<String> data){}}
class B extends A { void processData(List<Integer> data){}} is an invalid override
but
class A { void processData(List<String> data){}}
class B extends A { void processData(List<String> data){}} is an valid override

- hierarchy of Collections interfaces and classes that you will see on the exam.
> Collection
> List
> ArrayList

- Collection interface declares only the methods that are applicable to all sorts of collections and leaves the methods that deal with specialized features such as ordering or uniqueness of elements to sub-interfaces such as List and Set. For example, Collection declares add(Object e) and remove(Object e) methods but does not declare add(int index, Object e) and remove(int index) because the concept of ordering is not applicable to all collections. We use the Collection interface when we don't want to make any assumption about the characteristics of the group of objects. In other words, if we get a Collection object, all we know is that it contains a bunch of elements.

- Proper way to use and declare ArrayList
List<String> list = new ArrayList<String>(); or List<String> list = new ArrayList<>();

- Following declaration for ArrayList will generate warning.
List list = new ArrayList<String>();
List<String> list = new ArrayList();
List list = new ArrayList();

- Following declaration for ArrayList will generate error.
List<> list = new ArrayList<String>();  

- Advantages of ArrayList ☝
1. Dynamic sizing - An ArrayList can grow in size as required. The programmer doesn't have to worry about the length of the ArrayList while adding elements to it.
2. Type safety - An ArrayList can be made type safe using generics.
3. Readymade features - ArrayList provides methods for searching and for inserting elements anywhere in the list.

- Disadvantages of ArrayList ☝
1. Higher memory usage - An ArrayList generally requires more space than is necessary to hold the same number of elements in an array.
2. No type safety - Without generics, an ArrayList is not type safe at all.
3. No support for primitive values - ArrayLists cannot store primitive values while arrays can. This disadvantage has been mitigated somewhat with the introduction of autoboxing in Java 5, which makes it is possible to pass primitive values to various methods of an ArrayList. However, autoboxing does impact performance.

Similarities between ArrayLists and arrays ☝
1. Ordering - Both maintain the order of their elements.
2. Duplicates - Both allow duplicate elements to be stored.
3. nulls - Both allows nulls to be stored.
4. Performance - Since an ArrayList is backed by an array internally, there is no difference in performance of various operations such as searching on an ArrayList and on an array.
5. Thread safety - Neither of them are thread safe. Don't worry, thread safety is not on the exam, but you should be aware of the fact that accessing either of them from multiple threads, may produce incorrect results in certain situations.
 
- Arrays.asList method returns a fixed-size list backed by the specified array and as list is backed by the specified array therefore, you cannot add or remove elements from this list. Using add/remove methods cause an exception at runtime. But you can invoke the set(int index, E element) method on the returned list.

- List.of and List.copyOf method, which returns unmodifiable list, hence calling add/remove/set methods on the unmodifiable list throws an exception at runtime

- Iterable<T> interface has forEach(Consumer) method.  List<E> extends Collection<E> & Collection<E> extends Iterable<E>, therefore forEach(Consumer) can easily be invoked on reference variable of List<E> type.

- forEach(Consumer) method performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception. Consumer is a functional interface, hence a lambda expression can be passed.

- abstract class in java can have 0 or more abstract methods

-clone method of list interface create a shallow copy of list object. Means if an original list contains reference variables then after clone method a new list object is created which contains same reference objects as original object.

- All wrapper classes Integer, Float, Double, Character, Byte, Short, Boolean are immutable classes like a String class.

- If lambda expression is in {}, then it should have complete expression including semicolons and return statement if required.

- While implementing an interface method, this method should not have weaker access modifier than declared in interface.
Interface methods are public implicitly, so class which implements interface should also declare methods as public.

- Study ques40 for a very peculiar example of sub class implementing interface and extending base class which does not implements any interface but has a same method implemented as its member method (Test 2). If a sub class inherits method with same signature from both super and interface, then sub class will inherit super class version methods, but if super class has a weaker access modifier (not being public) than interface method, then it will cause a compilation error. To resolve this error either sub class should override that method with a public access modifier or super class method should be declared public. 

- Functional Interface can have only one non-overriding abstract method. Apart from it a functional interface can have constant variables, default methods, private methods, overriding abstract methods like public String toString(), public boolean equals(Object) and public int hashCode().

- While traversing a list using an iterator, if it is required to remove item from list use Iterator.remove or ListIterator.remove method, rather than List.remove method. As later method will throw java.util.ConcurrentModificationException.

- Variables defined in interface are implicitly public final static. Correct way of access interface variable is with syntax InterfaceName.variableName. But reference type can also point to interface variables.

- remove(Object o) method of list return true if object was removed successfully or false otherwise.

- remove(int index) remove the element of list at index and returns that element.

- add(E e) method of list return true if object was added successfully or false otherwise.
- add(int index, E element) inserts element at index. It returns void. if index is < 0 or > list length, then IndexOutOfBound exception is thrown.

- But note, java.util.ConcurrentModificationException will never be thrown for traditional for loop. It is thrown for for-each loop or while using Iterator/ListIterator.

- In this case `animals.remove(new StringBuilder("Alligator"));` will never remove any items from the list as StringBuilder class doesn't override the equals(Object) method of Object class.

- lambda expression can reference enclosing class instance variable as this.variablename.

- lambda expression can hide instance variable by redeclaring its own variable inside its {} block of code.

-  var name = List.of("Dhruv", "Poonam", "Daksh", "Parth"); // is a valid syntax to declare a list.
or var name = new ArrayList<String>(); // this is also valid statement

- var list = new ArrayList<>(); // refers to an ArrayList of Object type, because Generic type is not defined on the right side.

- If variable are declared in interface, it need to be initialized as variable in interface are implicitly public, static and final e.g
interface MyInterface{
int i;
} // it will cause compilation error
interface MyInterface{
int i = 10;
} // it will compilation fine

- Reference variable to which lambda expression is assigned is known as target type. Target type can be a static variable, instance variable, local variable, method parameter or return type. 

- Or you can typecast lambda expression to target type. e.g. following works:
interface Operator<T> {
    public abstract T operation(T t1, T t2);
}
System.out.println((Operator<String>)(String s1, String s2) -> s1 + s2);
System.out.println((Operator<String>)(s1, s2) -> s1 + s2);
System.out.println((Operator<String>)(s1, s2) -> { return s1 + s2; });

- If you want to invoke the default method implementation from the overriding method, then the correct syntax is: [Interface_name].super.[default_method_name]



MAIN OBSERVATIONS
-----------------
- under stand list api functions


Handling Exceptions (8 questions) -- 63%
----------------------------------------

- A function can declare to throw any exception(s) with throws clause. e.g public void copyFile(String inputPath, String outputPath) throws IOException{}

- A method can throw multiple type of exception with following syntax void method() throws IOException, SQLException, FileNotFoundException{}

- Calling method can deal with called method throwing exception in two ways.
1. By handling exception in try/catch block
2. By declaring throws clause in method declaration. 

- Method can use throw keyword to throw any exception from method body.

- Note that curly braces for the try, catch, and finally blocks are required even if there is a single statement in these blocks  (compare that to if, while, do/while and for blocks where curly braces are not required if there is only one statement in the block).  Furthermore, a try block must follow with at least one catch block or the finally block. A try block that follows with neither a catch block nor a finally block will not compile. 
 

- In exception handling order in which catch block is specified matter. if subclass exception is specified after super class exception, then it will be a compile error, compiler will state is as unreachable code.

- RuntimeException can be thrown without any need to be declared in throws clause of surrounding method.
throw (RuntimeException)e; doesn't cause any compilation error. Even though variable 'e' is type casted to RuntimeException but exception object is still of ArithmeticException, which is caught in main method and 'AE' is printed to the console. (Ques 6)

- Java doesn't allow to catch specific checked exceptions if these are not thrown by the statements inside try block.<--- Verified

- If an instance of Exception is thrown by the catch-block but another catch-block at the same level are not executed.
Explaining this point further, in a try catch block with multiple catch blocks only one of the catch block is executed even though an executed catch block throws new other type of exception. And as usual finally block is always executed.

- If a method has a throws clause and it throws unchecked exception then calling method don't need to handle that exception. But if method throws checked exception then calling method needs to handle that exception by either try/catch block or add throws clause to method signature.

- Casting Super class Exceptions like RuntimeException to sub class exception like ArithmeticException will cause ClassCastException to be thrown.

- An overriding method can only throw Checked exception and its sub type if and only if super class overridden method declared it throws checked exception.

- For instance if super class method throws IOException, so its legal for sub class to override a method with FileNotFoundException. But if super class overridden method is called in sub class overriding method, using super keyword then it will cause a compilation error as super class method throws a wider exception (IOException) and sub class throws only narrower exception (FileNotFoundException), which is illegal in java. Same rationale can be used in try catch block also, if try block throws wider exception and catch block only have narrower exception, it will be a compilation error. 

- An overriding method can throw unchecked exception even if its super class method does not throws any exception.

- Overriding method can choose not to throw any checked exception or throw any unchecked exception even if its super class overridden method throws checked exception. The other way rule applies to sub class overriding method.

- multi catch syntax: catch (Exception1 | Exception2 ex) {}. But Exception1 and Exception2 must be unrelated exception i.e. they should not have any is-a relationship.

- It is legal to throw exception as null with throw clause. But this would cause NullPointerException when this exception is catched tried to access its methods.

- According to overriding rules, if super class / interface method declares to throw a checked exception, then overriding method of sub class / implementer class has following options:
1. May not declare to throw any checked exception.
2. May declare to throw the same checked exception thrown by super class / interface method.
3. May declare to throw the sub class of the exception thrown by super class / interface method.
4. Cannot declare to throw the super class of the exception thrown by super class / interface method.
5. Cannot declare to throw unrelated checked exception.
6. May declare to throw any RuntimeException or Error.

- Only thing to remember is that if overridden method throws any unchecked exception or Error, then overriding method must not throw any checked exceptions.

- Java follows a convention in naming exception classes. This convention is sometimes helpful in determining the kind of exception you are dealing with. The name of any class that extends Error ends with Error and the name of any class than extends Exception ends with Exception. For example, OutOfMemoryError and StackOverflowError are Errors while IOException, SecurityException, IndexOutOfBoundsException are Exceptions. However, there is no way to distinguish between unchecked exceptions that extend RuntimeException and checked exceptions just by looking at their names. It is therefore, important to memorize the names of a few important runtime exception classes, namely - NullPointerException, ArrayIndexOutOfBoundsException, ArithmeticException, ClassCastException, and SecurityException.

- It is ok to catch an exception with wider class in catch block and rethown it. But if a exception variable is reassigned in catch block it will cause compilation error. e.g. -- work on it
private static void getData() throws SQLException {
        try {
            throw new SQLException();
        } catch (Exception e) {
            e = new SQLException(); // this line cause compilation error.
            throw e;
        }
    }

- Hierarchy of Exception framework
java.lang.Throwable (Root of all exception classes, is covered under checked exception)

Checked Exceptions
------------------
java.lang.Exceptions (Extends java.lang.Throwable)
some subclasses
> java.io.IOException
> java.sql.SQLException

Unchecked Exceptions
--------------------
java.lang.Error (Extends java.lang.Throwable)
some subclasses
> java.lang.AssertionError
> OutOfMemoryError
> java.lang.StackOverflowError

java.lang.RuntimeException
some subclasses
> java.lang.NullPointerException
> java.lang.ArrayIndexOutOfBoundsException
> java.lang.ArithmeticException
> java.lang.ClassCastException


- Common Exceptions that are usually thrown by the JVM
1. ArithmeticException extends RuntimeException. The JVM throws this exception when you try to divide a number by zero.
2. ClassCastException extends RuntimeException. The JVM throws this exception when you try to cast a reference variable to a type that fails the IS-A test.
3. IndexOutOfBoundsException extends RuntimeException. This exception is a common superclass of exceptions that are thrown where an invalid index is used to access a value that supports indexed access. For example, the JVM throws its subclass ArrayIndexOutOfBoundsException when you attempt to access an array with an invalid index value such as a negative value or a value that is greater than the length (minus one, of course) of the array. Methods of String class throw another of its subclass StringIndexOutOfBoundsException when you try to access a character at an invalid index.
4. NullPointerException extends RuntimeException 
The JVM throws this exception when you attempt to call a method or access a field using a reference variable that is pointing to null. 


- Common Errors usually thrown by the JVM
1. ExceptionInInitializerError extends Error. The JVM throws this Error when any exception is thrown while initializing a static variable or a static block. 
2. OutOfMemoryError extends Error. The JVM throws this Error when it runs out of memory. This usually happens when a programs creates too many objects. 
3. StackOverflowError extends Error. The JVM throws this Error when the thread executing the method runs out of stack space.

- Exceptions thrown by Application Programmer
1. IllegalArgumentException extends RuntimeException. This exception is thrown when a method receives an argument that the programmer has determined is not legal. 
2. NoClassDefFoundError extends Error.Although it is an Error but it is not thrown by the JVM. It is thrown by a class loader (which is just another class in Java standard library) when it is not able to find the definition of a class that it is trying to load. Beginners get this error often while trying to run their program. For example, if your class has a package statement but you have not put the class file in its proper directory structure, the system class loader will not be able to find that class when you try to run it and will throw this error.
3. NumberFormatException extends IllegalArgumentException. This exception is thrown when a method that converts a String to a number receives a String that it cannot convert. 
4. SecurityException extends RuntimeException. This exception is thrown if the Security Manager refuses to permit the requested operation due to restrictions placed by the JVM. For example, when a Java program runs in a sandbox (such as an applet) and tries to use prohibited APIs such as File I/O, the security manager throws this exception. Since this exception is explicitly thrown using the new keyword by a security manager class, it can be considered to be thrown by the application programmer. 

- If there is a possibility of a checked exception getting thrown out of a method, then that exception or its superclass exception must be declared in the throws clause of the method. 
Some of valid method declaration for methods throwing exception
1. void foo(int x) throws Exception{
    if(x == 2) throw new Exception(); //throws Exception only if x==2
    else return;
}

2. void foo() { //no throws clause necessary
    if(someCondition) throw new RuntimeException();
    else throw new Error();
}

3. void foo() throws Exception{
    if(someCondition) throw new java.io.IOException(); //throwing a sub-exception
    else return;
}

4. void foo() throws java.io.IOException{ //will not compile
    if(someCondition) throw new Exception(); //throwing a super-exception
    else return;
} 

5. void foo() throws java.io.IOException, java.sql.SQLException //can throw a common superclass exception as well.
{  
    if(someCondition) throw new java.io.IOException();
    else throw new java.sql.SQLException();
}

6. void foo() throws Exception, java.io.IOException{//specifying IOException is redundant because IOExcception is a subclass of Exception
    if(someCondition) throw new java.io.IOException();
    else throw new java.sql.SQLException();
}

7. void foo() throws Exception{ //declaring Exception in the throws clause even though it is not thrown by the method body
   System.out.println("hello");
}

8. void foo1() {
    try{
       if(someCondition) throw new Exception(); //will be caught by the catch block
       else return;
    }catch(Exception e){
       
    }
}

9. void foo2() throws Exception{
    try{
       if(someCondition) throw new Exception(); 
       else return;
    }finally {
       System.out.println("in finally"); //will be executed but the exception is not caught here
    }
}

10. void foo() throws Throwable{
    if(true) throw new Exception();
    else return;
}

- Therefore, if a static initializer ends up throwing an exception, there is no way for the application to handle that exception and to recover from it. For this reason, a static initializer is not allowed to throw any checked exception. If the compiler sees a possibility of a checked exception getting thrown out of a static initializer, it will generate an error.

- However, an instance initializer has the same problem as a static initializer - there is no way to specify a throws clause for an instance initializer. Recall that an instance initializer is executed no matter which constructor of the class is invoked. In that sense, an instance initializer is kind of a part of each constructor of the class. Therefore, an exception thrown from an instance initializer can be thought of as an exception thrown by every constructor of the class. Thus, if we declare an exception thrown from an instance initializer in the throws clause of each constructor of the class, we should be good.
e.g TestClass() throws Exception{}

- Just like a method, a constructor is allowed to throw any exception as long as it declares that exception in its throws clause. However, there is one important difference between a method and a constructor. Recall that the first line of every constructor is always a call to a constructor of its super class or to another constructor of the same class. Thus, if a constructor decides to throw an exception, it has an impact on the subclass because that exception will be propagated to the subclass constructor as well. Therefore, if a subclass constructor invokes a superclass constructor that throws an exception, that subclass constructor must also declare that exception in its throws clause. try/catch block usually doesn't work in constructor, again because first line has to be a call to constructor of its super class or to another constructor of the same class.

- It is ok to use a catch block with a broader exception class to catch a narrower exception.

- The reverse, i.e., using a catch block with a narrower exception to catch a broader exception is not acceptable.

- If a method doesn't want to catch the exception then it must declare that exception (or its superclass) in its throws clause. This is no different from the rule that you have seen before while creating a method that throws an exception. 

- Unreachable catch blocks. What if you move the catch(IOException ioe) block before the catch(FileNotFoundException fnfe) block? Well, the code will fail to compile. The catch(IOException ioe) clause will always satisfy a FileNotFoundException and so the control will never get to enter catch(FileNotFoundException fnfe) block.

- But remember that a catch block associated with a nested try statement cannot catch an exception thrown by the outer try block. 

- It is possible to rethrow the same exception (or throw a new one) from the catch block. You may want to do this if you want to do something upon receiving an exception before letting it propagate up the call chain. Of course, if it is a checked exception you would have to declare it in the throws clause of the method. The same effect can be achieved with a finally block. 

- Since there is no catch block to catch the Exception thrown by method from catch/finally block, the exception will automatically be thrown out of the method to the caller of method, but only after the code in the finally block is executed.

- If you throw an exception from the finally block, then the exception thrown from the try block or the catch block is ignored, and the exception thrown from the finally block is what gets thrown out of the method. 

- Even though the catch block throws Exception, the JVM doesn't throw it to the caller of bar. It waits until the finally block finishes execution. However, the finally block throws a new IOException. So the JVM ignores the Exception that it was about to throw to the caller and throws the IOException instead. As far as the compiler is concerned, it realizes that bar can only throw an IOException and not Exception to the caller and therefore, it is ok with listing just IOException in bar's throws clause.


MAIN OBSERVATIONS
-----------------
- under stand exception framework hierarchy

Understanding Modules (8 questions) --50%
------------------------------------------
- A valid package name would therefore, be a valid module name. In short, the name must be a valid Java identifier (so, special characters such as dash and slash are out but underscore and dot are in) and it should follow the reverse domain name pattern to avoid name clash.

- Module descriptor is the formal way to describe a module. Every module must have a module descriptor that specifies the name of the module, what it provides, and what it requires. A module descriptor is nothing but a file by the name module-info.java.

- The directory structures for the sources and for the compiled classes of a module are almost exactly the same as that of a package. The only difference is that while a package may reside in any folder, a module resides in a folder by the same name as the module. This rule applies to the source code as well as the class files. If the module directory contains the source code, it is called "source module definition" and if the module directory contains compiled classes, it is called "module definition".

- The exam expects you to be able to identify valid and invalid module names. As explained above, the rules for naming a module are the same as those for naming a package. Thus, for example, the following are valid module names: a (length is not important), _m (may start with and contain _), n$, (may start with and contain $), x1 (may contain a number) and a.b (may contain dots) but the following are invalid: 1x, (cannot start with a number), a-b, (cannot contain hyphens), and a..b (cannot contain consecutive dots).

- It is possible to compile module source files without using the --module option by listing the files (either individually or using a wildcard) that you want to compile.

- For the purpose of the exam, you are expected to know how to compile a module using the --module switch only.


- command to compile modules
javac -d <output_directory> -p <module_path> --module-source-path <root_source_directory> -m <modules_to_compile>
-p option can also be provided as --module-path
-m option can also be provided as --module
-d <output_directory>: directory where compiled module will be placed
-p <module_path>: list of path separated by ; on windows and : on linux/mac which contains various modules which may be required during the compilation of <module_to_compile>
--module-source-path <root_source_directory>: root source directory where all modules are kept. The compiler tries to locate this module in the paths specified in module-source-path.
-m <module_to_compile>: name of module directory to compile. Multiple modules are separated by commas
NOTE: -p option is not required if a module to compile does not require any external module to refer during compilation
Type of module that can be referred by -p option: singlemodules, exploded modules, modular jar

- command to create jar files
jar -c -e <main_class_name> -f <jar_file_name> -C <change_to_dir_to_include_files>
explanation of command line arguments
-c or --create: Create the archive
-f or --file=FILE: The archive file name
-e or --main-class=CLASSNAME
-C DIR: change to specified directory and include the following. This option is to make the jar tool change its working directory before adding files to the jar. We want it to step down to out\simpleinterest directory and then include the files from there.

- command to execute modules
java -p <module_path> -m <module>[/<mainclass>] [args...]
 -p option can also be provided as --module-path
 -m option can also be provided as --module
module_path(s) are separated by ; on windows and : on linux/mac
if each different module paths contain same module in them then first module path containing the requested module is executed and other module paths are ignored. (see question 12). -m option should be the last option as it could contain command line options.

- Note that the requirement of having the module-info.class in the root folder of the jar implies that it is not possible to package multiple modules in the same jar. In other words, you can have only one module per jar.

- You won't be tested on how to create a jar file in the exam. However, executing a module packaged in a jar file is on the exam. So, it would be good if you understand how a modular jar file is created.

- A module-path contains all the locations where you want the JVM to search for module definitions. While trying to load a module, the JVM looks for that module in all the locations specified in the module-path. It expects to find exactly one of the two things - a directory with the same name as the name of the module or a jar file containing module-info.class for that module. The name of the jar file is not important because the JVM takes the name of the module from the module-info.class contained in the jar file. The same module should not be present more than once on the module-path, otherwise the JVM will complain.

- exploded module is module with its own directory structure and class file. In exploded module main class is not optional.

- to create a jar file. First compile module from source file to class files as exploded module. From this exploded module create jar file as described above (jar command).

- some of valid module directives
 exports
 requires
 requires transitive
a module cannot export standard module of java platform e.g. java.se

- While exporting a package Wild-card (*) is not allowed with the package names

- requires or requires transitive directive should have module name and not package name in their declaration. 

- requires transitive: Implied readability is to specify a transitive dependency on another module such that other modules reading your module also read that dependency.
For example, if module C has `requires B;` (C reads B) and module B has `requires A;` (B reads A),
then C doesn't read A.

- Access and non-access modifiers are not allowed with module declaration.

- Only one module declaration is allowed in a module descriptor file.

- import statements are allowed in module descriptor file. These import statements are useful when you use 'provides' directive for Services but these are not in the scope of 1Z0-815 exam. For this exam you should know that import statements are allowed in module-info.java file.

- In the module descriptor file, if package specified in the exports directive is empty or doesn't exist, then compiler complains about it.

To have the transitive readability, 'requires transitive' directive is used. If module C has `requires B;`
(C reads B) and module B has `requires transitive A;` (B reads A [transitive dependency]), then C will also read A.

- export module to specific modules
exports <package_name> to <comma_separated_list_of_modules>;
if to <comma_separated_list_of_modules> is missing then package is exports to all modules
Also note that having multiple exports directive for same package is note allowed, below code causes compilation error:

exports com.udayankhattry.books to bookhouse;
exports com.udayankhattry.books to onlinestore;
but instead it should be
exports com.udayankhattry.books to bookhouse, onlinestore;

- A module is a set of packages and all the classes should be part of some package (not the default package).
unnamed package is not allowed in named modules (see question 35)

- In module-info.java name of module should be same as its root directory

- Java Platform Module System was introduced in Java 9 as project jigsaw

- When multiple modules with the same name are in different jar files on the module path, first module is selected and rest of the modules with same name are ignored. As first modular jar file in module path is 'secret_two.jar', hence com.udayankhattry.ocp1.Secret class defined in secret_two.jar file executes, which prints DEFEND on to the console.

- If a module exports a package to a missing module, then code will compile but will generate a warning about missing module.

- If a module have two packages e.g
dev.dmohindru.example;
dev.dmohindru.example.test;

and moduel-info.java has following code
module fullyQualifiedModuleName {
exports dev.dmohindru.example;
}
so this module declaration will export only dev.dmohindru.example package and not its sub package dev.dmohindru.example.test

- By default, all the Java modules are dependent on java.base module. There is no need to have 'requires' directive in the module descriptor file (module-info.java) for java.base module.

- To get a list of all the system modules, use below command:
java --list-modules

- And to check details of specific module (e.g. java.base), use below command:
java --describe-module java.base
--describe-module can also be specified as -d

- just reconcile keyword module, requires, to need module names and export need package name. e.g
module <module_name> {
	requires <module_name>;
	exports <package_name> to <module_name(s)_comma_seperated>;
	exports <package_name_1>;
}

- Duplicate import statement vs duplicate requires/export clauses
Having duplicate import statements in a Java source file doesn't make any sense but Java has, historically, permitted duplicate import statements. However, Java does not permit having duplicate requires clauses in a module info. Therefore, the following module-info.java will not compile:
module hr{
   requires valueobjects;
   requires valueobjects; //duplicate, not allowed
}

- Requiring the same module in a requires clause and in a requires transitive clause is not allowed either. Thus, the following will not compile:
module hr{
   requires valueobjects;
   requires transitive valueobjects; //duplicate, not allowed
}

- Compiling multiple modules
javac -d out --module-source-path src --module calculators,simpleinterest
In fact, Java will compile the calculators module even without us specifying it explicitly in the --module switch because javac will notice that simpleinterest requires calculators and so, it will compile calculators first. However, this is possible only when the source code of the module is organized correctly in the package driven directory structure. If the source files are organized differently, javac will not be able to locate them on its own.

- We can specify as many directories as we need separated by the path separator (; on windows and : on *nix). The difference between specifying a directory and specifying a jar is that when you specify a directory, all the jars as well as exploded module definitions present in that directory become available to the compiler (or to the jvm, in the case of execution), while in the other case, only the jar that you specify on the module path becomes available.

- a modular jar is no different from a regular non-modular jar from in terms of its structure. The only thing extra in a modular jar is the module-info.class in its root folder. In fact, it is possible to use a modular jar just like a non-modular jar. If you are wondering whether you can run the main class of a modular jar file the old way, then yes, you can. 

java -classpath calculators.jar;simpleinterest.jar simpleinterest.SimpleInterestCalculator 

- How will your code access classes from the non-modular jar? It is actually a very common scenario. You might want to use a third party logging framework, a JDBC driver, or a connection manager in your application. Java modules functionality provides a nice way to handle such situations. If you simply put a non-modular jar on the module-path, Java will consider the non-modular jar to be a module. Such a module is called automatic module and the name of this module is created automatically using the name of the jar file.

- Since there is no module-info.class in a non-modular jar, there is no way to specify the packages that it exports using the exports clauses or to specify the jars that it depends on using the requires clauses. For this reason, Java provides an automatic module with two special powers:
1. an automatic module exports all its packages (so that any module can "read" those packages) and
2. an automatic module is allowed to read all exported packages of modules that are available on the module-path as well as all classes available on the classpath.
For example, let's say our simpleinterest module requires com.mysql.jdbc.Driver class from mysql-driver-6.0.jar. We need to update the module info for simpleinterest as follows:
module simpleinterest{
   requires mysql.driver; //Observe that we are only specifying the module name here. All packages are exported automatically by an automatic module.
}
and, assuming that mysql-driver-6.0.jar is present in the jars directory, we will include it in the module-path of our javac as well as java commands as follows:
javac --module-path jars\mysql-driver-6.0.jar --module-source-path src -d out --module simpleinterest 
java --module-path jars\mysql-driver-6.0.jar;out --module simpleinterest/simpleinterest.SimpleInterestCalculator

- We must create an automatic module out of a non-modular jar only if a modular jar is statically dependent on a class from a non-modular jar, i.e., if a module refers to a class from the non-modular jar in its code and therefore, requires it during compilation. If an automatic module requires a class from a non-modular jar, you need to simply place the non-modular jar on the classpath during the execution of the module. Remember the second super power of an automatic module - an automatic module is allowed to read all classes available on the module-path as well as on the classpath. That is what makes it work. 
Thus, all we need to do is to include this jar on the classpath in our java command as follows:
java -classpath jars\commons-logging.jar --module-path jars\mysql-driver-6.0.jar; --module simpleinterest/simpleinterest.SimpleInterestCalculator

- Summary of command line switches used for compilation
1. --module-source-path: This switch is used to specify the location of the module source files.
2. -d: This switch is required when you compile a module. It is used to specify the output directory. This is the directory where javac will generate the module and package driven directory structure and the class files for the sources.
3. --module or -m: This switch is used when you want to compile all the source files of a particular module. This option is helpful when you want to compile all the files at once without listing any of the source files of a module individually in the command.
4. --module-path or -p: This option specifies the location(s) of any other module upon which the module to be compiled depends. You can specify the module directories or jar files containing the module classes here.
5. -classpath: This option is used for compilation of non-modular code. If you are compiling regular non-modular code but that code depends on some classes, then you can put those classes/jars on the classpath using -classpath option.

Summary of command line switches used for execution
1. --module-path or -p: This switch tells the location of the module definition. If the module is packaged in a jar file, then you can either specify the path to the jar, or specify the path to the directory where the jar file stored (relative to the current directory or an absolute path). 
For example, --module-path c:\javatest\modulejars. You can also specify the location where the compiled module exists in the exploded form. For example, if your module is named abc.math.utils and this module is stored in c:\javatest\output, then you can use: --module-path c:/javatest/output.  Remember that c:\javatest\output directory must contain abc.math.utils directory and the module files (including module-info.class) must be present in their appropriate directory structure under abc.math.utils directory.
2. --module or -m: This switch is used to specify the module that you want to run. For example, if you want to run abc.utils.Main class of abc.math.utils module, you should write --module abc.math.utils/abc.utils.Main
If a module jar's manifest contains the Main-Class property, you can omit the main class from the command. For example, you can write, --module abc.math.utils instead of --module abc.math.utils/abc.utils.Main.
3. -classpath or --class-path or -cp: This switch is used while executing non-modular code. It is also used while executing a modular code to specify non-modular jars that are required by the project.

- By Java 8, the standard Java library, with over four thousand five hundred classes, had become a big monolithic pile of interdependent classes and packages that was impossible to split into smaller independent pieces. Even if an application used a very small part of the runtime library, it still had to be bundled with the whole library. You might have heard about a jar file named rt.jar that every Java installation comes with. This 60 MB jar file contains the complete Java SE library. If you ever wanted to distribute your Java application comprising just a single class, you would have to include this huge jar file along with it.
Modular JDK is an effort to solve this problem. It divided the JDK into several loosely coupled modules that can be combined at compile time, build time, as well as run time, into a variety of configurations as per the needs of the applications. For example, a large service side application can use the full JDK but a micro-service can be packaged with only the modules that are absolutely essential. It also allows applications that are bundled along with the runtime, to be shipped with smaller profiles, thus, increasing the reach of Java applications to more devices and platforms. 

- The modules that are governed by the Java Community Process (JCP) are called Standard modules. Their names start with java. For example, java.base, java.sql, and java.logging are standard modules. All other modules that are specific to a JDK are called non-standard modules. Their names start with jdk. For example, jdk.jdeps, jdk.rmic, and jdk.javadoc are non-standard modules.

- It is important to know that a standard module may contain non-standard packages but a non-standard module does not contain any standard package.

- The Java SE Platform: The Java Platform, Standard Edition (Java SE) is the core Java platform for general-purpose computing. It is composed only of the standard modules (i.e. whose names start with java) and is required to be supported by all Java implementations. most commonly used modules in this platform are java.base, java.desktop, java.logging, java.sql, java.prefs, java.desktop, and java.net.http.

- If your module "requires" only the modules contained in the Java SE platform, it will depend only on the standard Java packages and will be portable to all Implementations of the Java SE Platform.

- The java.base Module: This module defines the foundational APIs of the Java SE platform. By foundational, we mean that it lies at the core of all Java platforms. This module doesn't require any other module but every other module depends on this module. Again, you need not remember the complete list of packages contained in this module but here are a few important packages that you should be aware of - java.lang, java.lang.annotation, java.io, java.nio, java.net, java.util, java.util.concurrent, java.security, and java.time. Of course, java.lang.Object belongs to this module, after all! But did you notice that we never wrote requires java.base; in the module declarations of the modules that we developed in the previous section? The reason is that since everything in Java requires packages exported from this module, the Java compiler does not require it to be specified explicitly. In other words, much like the java.lang package is not required to be imported in a class explicitly, the java.base module is not required to be specified in a requires clause of a module explicitly. It is always assumed to be "required". 

- java.se is an aggregator module.

- Note that you may see the use of phrases such as "core APIs" or "core packages" in problem statements or options of the questions in the exam. You should mark such options as incorrect. On the other hand, the phrase "foundational APIs" is used by the official  API description and is, therefore, correct. So, for the purpose of the exam, java.base defines all the "foundational APIs" and not all the "core APIs" of the Java platform.

- When you graduate to developing industrial strength Java applications, you will use several other tools such as jdb, javadoc, javap, and javaw.

- Command line options related to modules
--show-module-resolution: This new switch is applied to the java command to make it print module resolution information while executing a Java program. Basically, if you want to know what all modules are being referred to while running a program, this is the option to use. Note that the show-module-resolution option shows module level details only. It doesn't tell you which package or which class from a module is actually required. 

- jdeps is a new tool specifically designed to help you deal with modules without executing them. Using this tool, you can find out module, package, as well as class level dependencies of a given module. It can analyze an exploded module or a module jar. 

- jmod: Java 9 also introduces a new way to package Java code into "jmod" files. This packaging method is used when you need to package artifacts such as native code that can't be put in jar files. However, a jmod file cannot be executed and is therefore, only used at compile time and link time. It is not a replacement for jar files. Don't worry, you don't need to know anything about jmod files. But you may see it mentioned in an exam question as an option. If you see any option that mentions jmod, it is most likely an incorrect option.

- Benefits of the modular JDK
1. It makes the Java platform more easily scalable down to small devices. Since Java classes and packages are distributed into modules, it is possible to create a configuration with a small footprint by packaging just the modules that are required. For example, if an application does not require any GUI, there is no need to package the java.desktop module with it.
2. It improves security and maintainability. Before modules, all members of all classes, irrespective of their access modifiers, were accessible through reflection API. Now, by encapsulating packages into modules, the JVM is able to restrict reflective access only to packages that explicitly allow it. The use of explicit exports and requires clauses prevent inadvertent dependence on classes that are not meant to be used outside a module.
3. It improves application performance by not requiring unnecessary classes to be packaged and/or loaded.
4. It is backward compatible. It is not required for an application to be structured as modular to be run on the modular JDK. A non-modular application will still run just like before on the modular JDK using the -classpath option.
5. Customization is possible. It is possible to make the packages that are not exported explicitly in the module descriptor accessible through the use of appropriate command line options. For example, if a module does not export a package, you can still use the --add-exports option to make it accessible to other modules. Of course, this option breaks the encapsulation mechanism and is undesirable. It should be used only in exceptional circumstances.

- To have `import java.sql.*;` in the module-info.java file, `requires java.sql;` directive is needed, hence below is invalid code in module-info.java.
File name: module-info.java
import java.sql.*;
module com.data.sort {
    requires java.sql;
}

- In the module descriptor file, if package specified in the exports directive is empty or doesn't exist, then compiler complains about it.

- If question specifies a modular jar and does not state its main class attributes, then assume that its main class attribute is not set and hence when executing that modular jar complete path of its main class should be specified on command line.


Current read
------------

